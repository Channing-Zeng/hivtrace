{"version":3,"sources":["main.js","misc.js","histogram.js","clusternetwork.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACniBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hivtrace.js","sourcesContent":["var root = this;\r\n\r\ndatamonkey.hivtrace = function () {};\r\n\r\nif (typeof exports !== 'undefined') {\r\n\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = datamonkey.hivtrace;\r\n  }\r\n\r\n  exports.datamonkey.hivtrace = datamonkey.hivtrace;\r\n\r\n} else {\r\n\r\n  root.datamonkey.hivtrace = datamonkey.hivtrace;\r\n\r\n}\r\n","//_ = require('underscore');\r\n\r\nfunction hivtrace_cluster_adjacency_list(obj) {\r\n\r\n    var nodes = obj.Nodes,\r\n        edges = obj.Edges;\r\n\r\n\r\n    var adjacency_list = {};\r\n\r\n    edges.forEach(function(e, i) {\r\n\r\n        function in_nodes(n, id) {\r\n            return n.id == id;\r\n        }\r\n\r\n        var seq_ids = e[\"sequences\"];\r\n\r\n        var n1 = nodes.filter(function(n) {\r\n                return in_nodes(n, seq_ids[0])\r\n            })[0],\r\n            n2 = nodes.filter(function(n) {\r\n                return in_nodes(n, seq_ids[1])\r\n            })[0];\r\n\r\n        adjacency_list[n1.id] ? adjacency_list[n1.id].push(n2) : adjacency_list[n1.id] = [n2];\r\n        adjacency_list[n2.id] ? adjacency_list[n2.id].push(n1) : adjacency_list[n2.id] = [n1];\r\n\r\n    });\r\n\r\n\r\n    return adjacency_list;\r\n\r\n}\r\n\r\n\r\nfunction hivtrace_new_cluster_adjacency_list(obj) {\r\n\r\n    var nodes = obj.Nodes,\r\n        edges = obj.Edges;\r\n\r\n\r\n    nodes.forEach (function (n) {\r\n        n.neighbors = d3.set();\r\n    });\r\n    \r\n    edges.forEach (function (e) {\r\n        nodes[e.source].neighbors.add(e.target);\r\n        nodes[e.target].neighbors.add(e.source);\r\n    });\r\n\r\n}\r\n\r\n// Reconstructs path from floyd-warshall algorithm\r\nfunction hivtrace_get_path(next, i, j) {\r\n\r\n    var all_paths = [];\r\n    var i = parseInt(i);\r\n    var j = parseInt(j);\r\n\r\n    for (var c = 0; c < next[i][j].length; c++) {\r\n\r\n        var k = next[i][j][c];\r\n        var intermediate = k;\r\n\r\n        if (intermediate == null || intermediate == i) {\r\n            return [\r\n                [parseInt(i), parseInt(j)]\r\n            ];\r\n        } else {\r\n\r\n            var paths_i_k = hivtrace_get_path(next, i, intermediate);\r\n            var paths_k_j = hivtrace_get_path(next, intermediate, j);\r\n\r\n            for (var i_k_index = 0; i_k_index < paths_i_k.length; i_k_index++) {\r\n                var i_k = paths_i_k[i_k_index];\r\n                for (var k_j_index = 0; k_j_index < paths_k_j.length; k_j_index++) {\r\n                    var k_j = paths_k_j[k_j_index];\r\n                    if (i_k.length) {\r\n                        if ((i_k[0] == i) && (i_k[i_k.length - 1] == k) && (k_j[0] == k) && (k_j[k_j.length - 1] == j)) {\r\n                            i_k.pop()\r\n                            all_paths.push(i_k.concat(k_j));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return all_paths;\r\n\r\n}\r\n\r\nfunction hivtrace_paths_with_node(node, next, i, j) {\r\n\r\n    var paths = hivtrace_get_path(next, i, j);\r\n\r\n    // Retrieve intermediary paths\r\n    paths = paths.map(function(sublist) {\r\n        return sublist.slice(1, -1)\r\n    });\r\n\r\n    if (!paths) {\r\n        return 0;\r\n    }\r\n\r\n    var num_nodes = [];\r\n\r\n    for (var i = 0; i < paths.length; i++) {\r\n        sublist = paths[i];\r\n        num_nodes.push(d3.sum(sublist.map(function(n) {\r\n            return n == node;\r\n        })));\r\n    }\r\n\r\n    var mean = d3.mean(num_nodes);\r\n\r\n    if (mean == undefined) {\r\n        mean = 0;\r\n    }\r\n\r\n    return mean;\r\n\r\n}\r\n\r\n\r\n// Same as compute shortest paths, but with an additional next parameter for reconstruction\r\nfunction hivtrace_compute_shortest_paths_with_reconstruction(obj, subset, use_actual_distances) {\r\n\r\n    // Floyd-Warshall implementation\r\n    var distances = [];\r\n    var next = [];\r\n    var nodes = obj.Nodes;\r\n    var edges = obj.Edges;\r\n    var node_ids = [];\r\n\r\n    var adjacency_list = datamonkey.hivtrace.cluster_adjacency_list(obj);\r\n\r\n    if (!subset) {\r\n        subset = Object.keys(adjacency_list);\r\n    }\r\n\r\n    var node_count = subset.length;\r\n\r\n    for (var i = 0; i < subset.length; i++) {\r\n        var a_node = subset[i];\r\n        var empty_arr = _.range(node_count).map(function(d) {\r\n            return null\r\n        });\r\n        var zeroes = _.range(node_count).map(function(d) {\r\n            return null\r\n        });\r\n        distances.push(zeroes);\r\n        next.push(empty_arr);\r\n    };\r\n\r\n    for (var index = 0; index < subset.length; index++) {\r\n        var a_node = subset[index];\r\n        for (var index2 = 0; index2 < subset.length; index2++) {\r\n            var second_node = subset[index2];\r\n            if (second_node != a_node) {\r\n                if (adjacency_list[a_node].map(function(n) {\r\n                        return n.id\r\n                    }).indexOf(second_node) != -1) {\r\n                    distances[index][index2] = 1;\r\n                    distances[index2][index] = 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for (var index_i = 0; index_i < subset.length; index_i++) {\r\n        var n_i = subset[index_i];\r\n        for (var index_j = 0; index_j < subset.length; index_j++) {\r\n            var n_j = subset[index_j];\r\n            if (index_i == index_j) {\r\n                next[index_i][index_j] = [];\r\n            } else {\r\n                next[index_i][index_j] = [index_i];\r\n            }\r\n        }\r\n    }\r\n\r\n    // clone distances\r\n    var distances2 = _.map(distances, _.clone);\r\n    var c = 0;\r\n\r\n    for (var index_k = 0; index_k < subset.length; index_k++) {\r\n        var n_k = subset[index_k];\r\n        for (var index_i = 0; index_i < subset.length; index_i++) {\r\n            var n_i = subset[index_i];\r\n            for (var index_j = 0; index_j < subset.length; index_j++) {\r\n                var n_j = subset[index_j];\r\n\r\n                if (n_i != n_j) {\r\n\r\n                    d_ik = distances[index_k][index_i];\r\n                    d_jk = distances[index_k][index_j];\r\n                    d_ij = distances[index_i][index_j];\r\n\r\n                    if (d_ik != null && d_jk != null) {\r\n                        d_ik += d_jk;\r\n                        if (d_ij == null || (d_ij > d_ik)) {\r\n                            distances2[index_i][index_j] = d_ik;\r\n                            distances2[index_j][index_i] = d_ik;\r\n                            next[index_i][index_j] = [];\r\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\r\n                            continue;\r\n                        } else if (d_ij == d_ik) {\r\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\r\n                        }\r\n                    }\r\n                    c++;\r\n                    distances2[index_j][index_i] = distances[index_j][index_i];\r\n                    distances2[index_i][index_j] = distances[index_i][index_j];\r\n                }\r\n            }\r\n        }\r\n\r\n        var t = distances2;\r\n        distances2 = distances;\r\n        distances = t;\r\n\r\n    }\r\n\r\n    return {\r\n        'ordering': subset,\r\n        'distances': distances,\r\n        'next': next\r\n    };\r\n\r\n}\r\n\r\nfunction hivtrace_filter_to_node_in_cluster(node, obj) {\r\n\r\n    var nodes = obj.Nodes,\r\n        edges = obj.Edges,\r\n        cluster_id = null;\r\n\r\n    // Retrieve nodes that are part of the cluster\r\n    var node_obj = nodes.filter(function(n) {\r\n        return node == n.id;\r\n    });\r\n\r\n    if (node_obj) {\r\n        cluster_id = node_obj[0].cluster;\r\n    } else {\r\n        console.log('could not find node');\r\n        return null;\r\n    }\r\n\r\n    // Filter out all edges and nodes that belong to the cluster\r\n    var nodes_in_cluster = nodes.filter(function(n) {\r\n        return cluster_id == n.cluster;\r\n    });\r\n    var node_ids = nodes_in_cluster.map(function(n) {\r\n        return n.id\r\n    });\r\n    var edges_in_cluster = edges.filter(function(e) {\r\n        return node_ids.indexOf(e.sequences[0]) != -1\r\n    });\r\n\r\n    var filtered_obj = {};\r\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\r\n    filtered_obj[\"Edges\"] = edges_in_cluster;\r\n    return filtered_obj;\r\n\r\n}\r\n\r\nfunction hivtrace_compute_betweenness_centrality_all_nodes_in_cluster(cluster, obj, cb) {\r\n\r\n    var nodes = obj.Nodes,\r\n        edges = obj.Edges;\r\n\r\n\r\n    var nodes_in_cluster = nodes.filter(function(n) {\r\n        return cluster == n.cluster;\r\n    });\r\n    var node_ids = nodes_in_cluster.map(function(n) {\r\n        return n.id\r\n    });\r\n    var edges_in_cluster = edges.filter(function(e) {\r\n        return node_ids.indexOf(e.sequences[0]) != -1\r\n    });\r\n\r\n    var filtered_obj = {};\r\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\r\n    filtered_obj[\"Edges\"] = edges_in_cluster;\r\n\r\n    // get length of cluster\r\n    if (nodes_in_cluster.length > 70) {\r\n        cb('cluster too large', null);\r\n        return;\r\n    }\r\n\r\n    // get paths\r\n    var paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\r\n    var node_ids = nodes_in_cluster.map(function(n) {\r\n        return n.id\r\n    });\r\n\r\n    var betweenness = {}\r\n    nodes_in_cluster.forEach(function(n) {\r\n        betweenness[n.id] = hivtrace_compute_betweenness_centrality(n.id, filtered_obj, paths);\r\n    });\r\n\r\n    cb(null, betweenness);\r\n    return;\r\n\r\n}\r\n\r\n// Returns dictionary of nodes' betweenness centrality\r\n// Utilizes the Floyd-Warshall Algorithm with reconstruction\r\nfunction hivtrace_compute_betweenness_centrality(node, obj, paths) {\r\n\r\n    if (!paths) {\r\n        var filtered_obj = hivtrace_filter_to_node_in_cluster(node, obj)\r\n        paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\r\n    }\r\n\r\n    // find index of id\r\n    var index = paths['ordering'].indexOf(node);\r\n\r\n    if (index == -1) {\r\n        return null;\r\n    }\r\n\r\n    var length = paths['distances'].length;\r\n\r\n    if (length != 2) {\r\n        scale = 1 / ((length - 1) * (length - 2));\r\n    } else {\r\n        scale = 1;\r\n    }\r\n\r\n\r\n    // If s->t goes through 1, add to sum\r\n    // Reconstruct each shortest path and check if node is in it\r\n    var paths_with_node = [];\r\n    for (i in _.range(length)) {\r\n        for (j in _.range(length)) {\r\n            paths_with_node.push(hivtrace_paths_with_node(index, paths['next'], i, j));\r\n        }\r\n    }\r\n\r\n    return d3.sum(paths_with_node) * scale;\r\n\r\n}\r\n\r\n\r\nfunction hivtrace_compute_node_degrees(obj) {\r\n\r\n    var nodes = obj.Nodes,\r\n        edges = obj.Edges;\r\n\r\n    for (var n in nodes) {\r\n        nodes[n].degree = 0;\r\n    }\r\n\r\n    for (var e in edges) {\r\n        nodes[edges[e].source].degree++;\r\n        nodes[edges[e].target].degree++;\r\n    }\r\n\r\n}\r\n\r\nfunction hivtrace_get_node_by_id(id, obj) {\r\n    return obj.Nodes.filter(function(n) {\r\n        return id == n.id\r\n    })[0] || undefined;\r\n}\r\n\r\nfunction hivtrace_compute_cluster_betweenness(obj, callback) {\r\n\r\n    var nodes = obj.Nodes;\r\n\r\n    function onlyUnique(value, index, self) {\r\n        return self.indexOf(value) === index;\r\n    }\r\n\r\n    // Get all unique clusters\r\n    var clusters = nodes.map(function(n) {\r\n        return n.cluster\r\n    });\r\n    var unique_clusters = clusters.filter(onlyUnique);\r\n\r\n    var cb_count = 0;\r\n\r\n    function cb(err, results) {\r\n\r\n        cb_count++;\r\n\r\n        for (node in results) {\r\n            hivtrace_get_node_by_id(node, obj)['betweenness'] = results[node];\r\n        }\r\n\r\n        if (cb_count >= unique_clusters.length) {\r\n            callback('done');\r\n        }\r\n\r\n    }\r\n\r\n    // Compute betweenness in parallel\r\n    unique_clusters.forEach(function(cluster_id) {\r\n        datamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster(cluster_id, obj, cb);\r\n    });\r\n\r\n    // once all settled callback\r\n\r\n}\r\n\r\n\r\nfunction hivtrace_is_contaminant(node) {\r\n    return node.attributes.indexOf('problematic') != -1;\r\n}\r\n\r\nfunction hivtrace_convert_to_csv(obj, callback) {\r\n    //Translate nodes to rows, and then use d3.format\r\n    hivtrace_compute_node_degrees(obj);\r\n\r\n    hivtrace_compute_cluster_betweenness(obj, function(err) {\r\n        var node_array = obj.Nodes.map(function(d) {\r\n            return [d.id, d.cluster, d.degree, d.betweenness, hivtrace_is_contaminant(d), d.attributes.join(';')]\r\n        });\r\n        node_array.unshift(['seqid', 'cluster', 'degree', 'betweenness', 'is_contaminant', 'attributes'])\r\n        node_csv = d3.csv.format(node_array);\r\n        callback(null, node_csv);\r\n    });\r\n}\r\n\r\nfunction hivtrace_export_csv_button(graph, tag) {\r\n\r\n    var data = hivtrace_convert_to_csv(graph, function(err, data) {\r\n        if (data != null) {\r\n            var pom = document.createElement('a');\r\n            pom.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(data));\r\n            pom.setAttribute('download', 'export.csv');\r\n            pom.className = 'btn btn-default btn-sm';\r\n            pom.innerHTML = '<span class=\"glyphicon glyphicon-floppy-save\"></span> Export Results';\r\n            $(tag).append(pom);\r\n        }\r\n    });\r\n\r\n}\r\n\r\nfunction hiv_trace_export_table_to_text(parent_id, table_id, sep) {\r\n\r\n    var the_button = d3.select(parent_id).append(\"a\")\r\n        .attr(\"target\", \"_blank\")\r\n        .on(\"click\", function(data, element) {\r\n            var table_tag = d3.select(this).attr(\"data-table\");\r\n            var table_text = datamonkey.helpers.table_to_text(table_tag);\r\n            datamonkey.helpers.export_handler(table_text, table_tag.substring(1) + \".tsv\", \"text/tab-separated-values\");\r\n        })\r\n        .attr(\"data-table\", table_id);\r\n\r\n    the_button.append(\"i\").classed(\"fa fa-download fa-2x\", true);\r\n    return the_button;\r\n\r\n}\r\n\r\nhivtrace_compute_local_clustering_coefficients = _.once (function (obj) {\r\n\r\n  datamonkey.hivtrace.new_cluster_adjacency_list(obj);\r\n\r\n  var nodes = obj.Nodes;\r\n\r\n  nodes.forEach (function (n) {\r\n  \r\n    var a_node = n;\r\n    var neighborhood_size = a_node.neighbors.size();\r\n\r\n    if (neighborhood_size < 2) {\r\n        a_node.lcc = undefined;\r\n    } else {\r\n\r\n        if (neighborhood_size > 500) {\r\n            a_node.lcc = datamonkey.hivtrace.too_large;     \r\n        } else {\r\n            // count triangles\r\n            neighborhood = a_node.neighbors.values();\r\n            counter = 0;\r\n            for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\r\n                for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\r\n                    if (nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\r\n                        counter ++;\r\n                    }\r\n                }\r\n            }\r\n            a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\r\n        }\r\n    }\r\n\r\n  });\r\n\r\n});\r\n\r\nfunction hivtrace_render_settings(settings, explanations) {\r\n    // TODO:\r\n    //d3.json (explanations, function (error, expl) {\r\n    //    //console.log (settings);\r\n    //});\r\n}\r\n\r\nfunction hivtrace_format_value(value, formatter) {\r\n\r\n    if (typeof value === 'undefined') {\r\n        return \"Not computed\";\r\n    }\r\n    if (value === datamonkey.hivtrace.undefined) {\r\n        return \"Undefined\";\r\n    }\r\n    if (value === datamonkey.hivtrace.too_large) {\r\n        return \"Size limit\";\r\n    }\r\n\r\n    if (value === datamonkey.hivtrace.processing) {\r\n        return '<span class=\"fa fa-spin fa-spinner\"></span>';\r\n    }\r\n\r\n    return formatter ? formatter(value) : value;\r\n\r\n}\r\n\r\n\r\nif (typeof datamonkey == 'undefined') {\r\n    datamonkey = function() {};\r\n}\r\n\r\nif (typeof datamonkey.hivtrace == 'undefined') {\r\n    datamonkey.hivtrace = function() {};\r\n}\r\n\r\ndatamonkey.hivtrace.compute_node_degrees = hivtrace_compute_node_degrees;\r\ndatamonkey.hivtrace.export_csv_button = hivtrace_export_csv_button;\r\ndatamonkey.hivtrace.convert_to_csv = hivtrace_convert_to_csv;\r\ndatamonkey.hivtrace.betweenness_centrality = hivtrace_compute_betweenness_centrality;\r\ndatamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster = hivtrace_compute_betweenness_centrality_all_nodes_in_cluster;\r\ndatamonkey.hivtrace.cluster_adjacency_list = hivtrace_cluster_adjacency_list;\r\ndatamonkey.hivtrace.new_cluster_adjacency_list = hivtrace_new_cluster_adjacency_list;\r\ndatamonkey.hivtrace.analysis_settings = hivtrace_render_settings;\r\ndatamonkey.hivtrace.export_table_to_text = hiv_trace_export_table_to_text;\r\ndatamonkey.hivtrace.compute_local_clustering = hivtrace_compute_local_clustering_coefficients;\r\ndatamonkey.hivtrace.undefined = new Object();\r\ndatamonkey.hivtrace.too_large = new Object();\r\ndatamonkey.hivtrace.processing = new Object();\r\ndatamonkey.hivtrace.format_value = hivtrace_format_value;\r\n","function hivtrace_histogram(graph, histogram_tag, histogram_label) {  \r\n\r\n  var defaultFloatFormat = d3.format(\",.2f\");\r\n  var histogram_w = 300,\r\n  histogram_h = 300;\r\n\r\n  hivtrace_render_histogram(graph[\"Degrees\"][\"Distribution\"], \r\n                            graph[\"Degrees\"][\"fitted\"], \r\n                            histogram_w, \r\n                            histogram_h, \r\n                            histogram_tag);\r\n  var label = \"Network degree distribution is best described by the <strong>\" + graph[\"Degrees\"][\"Model\"] + \"</strong> model, with &rho; of \" + \r\n             defaultFloatFormat(graph[\"Degrees\"][\"rho\"]);\r\n             \r\n  if (graph[\"Degrees\"][\"rho CI\"] != undefined) {\r\n        label += \" (95% CI \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][0]) + \" - \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][1]) + \")\";\r\n  }\r\n\r\n  d3.select (histogram_label).html(label);\r\n}\r\n\r\nfunction hivtrace_render_histogram(counts, fit, w, h, id) {\r\n\r\n    var margin = {top: 10, right: 30, bottom: 50, left: 30},\r\n                width = w - margin.left - margin.right,\r\n                height = h - margin.top - margin.bottom;\r\n    \r\n    var x = d3.scale.linear()\r\n            .domain([0, counts.length+1])\r\n            .range([0, width]);\r\n            \r\n    var y = d3.scale.log()\r\n            .domain ([1, d3.max (counts)])\r\n            .range  ([height,0]);\r\n            \r\n    var total = d3.sum(counts);\r\n\r\n    var xAxis = d3.svg.axis()\r\n        .scale(x)\r\n        .orient(\"bottom\");\r\n        \r\n    var histogram_svg = d3.select(id).selectAll(\"svg\");\r\n\r\n    if (histogram_svg != undefined) {\r\n        histogram_svg.remove();\r\n    }\r\n    \r\n    var data_to_plot = counts.map (function (d, i) {return {'x' : i+1, 'y' : d+1};});\r\n    data_to_plot.push ({'x' : counts.length+1, 'y' : 1});\r\n    data_to_plot.push ({'x' : 0, 'y' : 1});\r\n    data_to_plot.push ({'x' : 0, 'y' : counts[0]+1});\r\n   \r\n    histogram_svg = d3.select(id).insert(\"svg\",\".histogram-label\")\r\n    .attr(\"width\", width + margin.left + margin.right)\r\n    .attr(\"height\", height + margin.top + margin.bottom)\r\n    .append(\"g\")\r\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\r\n    .datum (data_to_plot);\r\n        \r\n    var histogram_line = d3.svg.line()\r\n                        .x(function(d) { return x(d.x); })\r\n                        .y(function(d) { return y(d.y); })\r\n                        .interpolate(\"step-before\");\r\n                        \r\n    histogram_svg.selectAll (\"path\").remove();\r\n    histogram_svg.append (\"path\")\r\n                 .attr (\"d\", function(d) { return histogram_line(d) + \"Z\"; })\r\n                 .attr (\"class\", \"histogram\");\r\n    \r\n    /*var bar = histogram_svg.selectAll(\".bar\")\r\n    .data(counts.map (function (d) { return d+1; }))\r\n    .enter().append(\"g\")\r\n    .attr(\"class\", \"bar\")\r\n    .attr(\"transform\", function(d,i) { return \"translate(\" + x(i+1) + \",\" + y(d) + \")\"; });\r\n      \r\n    bar.append(\"rect\")\r\n        .attr(\"x\", 1)\r\n        .attr(\"width\", function (d,i) {return x(i+2) - x(i+1);})\r\n        .attr(\"height\", function(d) { return height - y(d); })\r\n        .append (\"title\").text (function (d,i) { return \"\" + counts[i] + \" nodes with degree \" + (i+1);});*/\r\n        \r\n      \r\n\r\n      if (fit != undefined) {    \r\n          var fit_line = d3.svg.line()\r\n              .interpolate(\"linear\")\r\n              .x(function(d,i) { return x(i+1) + (x(i+1)-x(i))/2; })\r\n              .y(function(d) { return y(1+d*total); });\r\n          histogram_svg.append(\"path\").datum(fit)\r\n            .attr(\"class\", \"line\")\r\n            .attr(\"d\", function(d) { return fit_line(d); });\r\n      }\r\n    \r\n    var x_axis = histogram_svg.append(\"g\")\r\n        .attr(\"class\", \"x axis\")\r\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\r\n        .call(xAxis);    \r\n        \r\n    x_axis.selectAll (\"text\").attr (\"transform\", \"rotate(45)\").attr(\"dx\",\"1em\").attr(\"dy\",\"0.5em\");\r\n}\r\n\r\ndatamonkey.hivtrace.histogram = hivtrace_histogram;\r\n","var _networkGraphAttrbuteID = \"user attributes\";\r\nvar _defaultFloatFormat = d3.format(\",.2r\");\r\n\r\n\r\n\r\nvar hivtrace_cluster_network_graph = function (json, network_container, network_status_string, network_warning_tag, button_bar_ui, attributes, filter_edges_toggle, clusters_table, nodes_table, parent_container) {\r\n\r\n  // [REQ] json                        :          the JSON object containing network nodes, edges, and meta-information\r\n  // [REQ] network_container           :          the CSS selector of the DOM element where the SVG containing the network will be placed (e.g. '#element')\r\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\r\n  // [OPT] network_warning_tag         :          the CSS selector of the DOM element where the any warning messages would go (e.g. '#element')\r\n  // [OPT] button_bar_ui               :          the ID of the control bar which can contain the following elements (prefix = button_bar_ui value)\r\n  //                                                - [prefix]_cluster_operations_container : a drop-down for operations on clusters\r\n  //                                                - [prefix]_attributes :  a drop-down for operations on attributes\r\n  //                                                - [prefix]_filter : a text box used to search the graph\r\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\r\n  // [OPT] attributes                  :          A JSON object with mapped node attributes\r\n\r\n  var self = new Object;\r\n\r\n    self.ww = d3.select(parent_container).property(\"clientWidth\");\r\n    self.nodes = [];\r\n    self.edges = [];\r\n    self.clusters = [];         \r\n    self.cluster_sizes = [];\r\n    self.colorizer = {'selected': function (d) {return d == 'selected' ? d3.rgb(51, 122, 183) : '#FFF';}}\r\n    self.filter_edges = true,\r\n    self.hide_hxb2 = false,\r\n    self.charge_correction = 1,\r\n    self.margin = {top: 20, right: 10, bottom: 30, left: 10},\r\n    self.width  = self.ww - self.margin.left - self.margin.right,\r\n    self.height = 500 - self.margin.top - self.margin.bottom,\r\n    self.cluster_table = d3.select (clusters_table),\r\n    self.node_table = d3.select (nodes_table),\r\n    self.needs_an_update = false,\r\n    self.json = json;\r\n\r\n  var cluster_mapping = {},\r\n      l_scale = 5000,   // link scale\r\n      graph_data = self.json,     // the raw JSON network object\r\n      max_points_to_render = 500,\r\n      warning_string     = \"\",\r\n      singletons         = 0,\r\n      open_cluster_queue = [],\r\n      currently_displayed_objects;\r\n\r\n  /*------------ D3 globals and SVG elements ---------------*/\r\n\r\n  var network_layout = d3.layout.force()\r\n    .on(\"tick\", tick)\r\n    .charge(function(d) { if (d.cluster_id) return self.charge_correction*(-50-20*Math.pow(d.children.length,0.7)); return self.charge_correction*(-20*Math.sqrt(d.degree)); })\r\n    .linkDistance(function(d) { return Math.max(d.length*l_scale,1); })\r\n    .linkStrength (function (d) { if (d.support != undefined) { return 2*(0.5-d.support);} return 1;})\r\n    .chargeDistance (500)\r\n    .friction (0.25);\r\n        \r\n  d3.select(network_container).selectAll (\".my_progress\").remove();\r\n\r\n  var network_svg = d3.select(network_container).append(\"svg:svg\")\r\n      .style (\"border\", \"solid black 1px\")\r\n      .attr(\"id\", \"network-svg\")\r\n      .attr(\"width\", self.width + self.margin.left + self.margin.right)\r\n      .attr(\"height\", self.height + self.margin.top + self.margin.bottom);\r\n\r\n      //.append(\"g\")\r\n      // .attr(\"transform\", \"translate(\" + self.margin.left + \",\" + self.margin.top + \")\");\r\n\r\n  network_svg.append(\"defs\").append(\"marker\")\r\n      .attr(\"id\", \"arrowhead\")\r\n      .attr(\"refX\", 9) /*must be smarter way to calculate shift*/\r\n      .attr(\"refY\", 2)\r\n      .attr(\"markerWidth\",  6)\r\n      .attr(\"markerHeight\", 4)\r\n      .attr(\"orient\", \"auto\")\r\n      .attr(\"stroke\", \"#666666\")\r\n      .attr(\"fill\", \"#AAAAAA\")\r\n      .append(\"path\")\r\n          .attr(\"d\", \"M 0,0 V 4 L6,2 Z\"); //this is actual shape for arrowhead\r\n   \r\n  change_window_size();                                   \r\n   \r\n  /*------------ Network layout code ---------------*/\r\n  var handle_cluster_click = function (cluster, release) {\r\n\r\n    var container = d3.select(network_container);\r\n    var id = \"d3_context_menu_id\";\r\n    var menu_object = container.select (\"#\" + id);\r\n    \r\n    if (menu_object.empty()) {\r\n      menu_object = container.append (\"ul\")\r\n        .attr (\"id\", id)\r\n        .attr (\"class\",\"dropdown-menu\")\r\n        .attr (\"role\", \"menu\");\r\n    } \r\n\r\n    menu_object.selectAll (\"li\").remove();\r\n\r\n    var already_fixed = cluster && cluster.fixed == 1;\r\n    \r\n\r\n    if (cluster) {\r\n      menu_object.append(\"li\").append (\"a\")\r\n                   .attr(\"tabindex\", \"-1\")\r\n                   .text(\"Expand cluster\")\r\n                   .on (\"click\", function (d) {\r\n                      cluster.fixed = 0;\r\n                      expand_cluster_handler(cluster, true);\r\n                      menu_object.style (\"display\", \"none\"); \r\n                      });\r\n\r\n      menu_object.append(\"li\").append (\"a\")\r\n                   .attr (\"tabindex\", \"-1\")\r\n                   .text (\"Center on screen\")\r\n                   .on (\"click\", function (d) {\r\n                      cluster.fixed = 0;\r\n                      center_cluster_handler(cluster);\r\n                      menu_object.style (\"display\", \"none\"); \r\n                      });\r\n                      \r\n     menu_object.append(\"li\").append (\"a\")\r\n               .attr (\"tabindex\", \"-1\")\r\n               .text (function (d) {if (cluster.fixed) return \"Release fix\"; return \"Fix in place\";})\r\n               .on (\"click\", function (d) {\r\n                  cluster.fixed = !cluster.fixed;\r\n                  menu_object.style (\"display\", \"none\"); \r\n                  });\r\n\r\n     cluster.fixed = 1;\r\n\r\n     menu_object.style (\"position\", \"absolute\")\r\n        .style(\"left\", \"\" + d3.event.offsetX + \"px\")\r\n        .style(\"top\", \"\" + d3.event.offsetY + \"px\")\r\n        .style(\"display\", \"block\");\r\n\r\n    } else {\r\n      if (release) {\r\n        release.fixed = 0;\r\n      }\r\n      menu_object.style(\"display\", \"none\");\r\n    }\r\n\r\n    container.on(\"click\", function (d) {handle_cluster_click(null, already_fixed ? null : cluster);}, true);\r\n\r\n  };\r\n\r\n  var handle_node_click = function (node) {\r\n    var container = d3.select(network_container);\r\n    var id = \"d3_context_menu_id\";\r\n    var menu_object = container.select (\"#\" + id);\r\n    \r\n    if (menu_object.empty()) {\r\n      menu_object = container.append (\"ul\")\r\n        .attr (\"id\", id)\r\n        .attr (\"class\",\"dropdown-menu\")\r\n        .attr (\"role\", \"menu\");\r\n    } \r\n\r\n    menu_object.selectAll (\"li\").remove();\r\n\r\n    if (node) {\r\n      node.fixed = 1;\r\n      menu_object.append(\"li\").append (\"a\")\r\n                   .attr(\"tabindex\", \"-1\")\r\n                   .text(\"Collapse cluster\")\r\n                   .on (\"click\", function (d) {\r\n                      node.fixed = 0;\r\n                      collapse_cluster_handler(node, true)\r\n                      menu_object.style (\"display\", \"none\"); \r\n                      });\r\n\r\n      menu_object.style (\"position\", \"absolute\")\r\n        .style (\"left\", \"\" + d3.event.offsetX + \"px\")\r\n        .style (\"top\", \"\" + d3.event.offsetY + \"px\")\r\n        .style (\"display\", \"block\");\r\n\r\n    } else {\r\n      menu_object.style(\"display\", \"none\");\r\n    }\r\n\r\n    container.on(\"click\", function (d) {handle_node_click(null);}, true);\r\n\r\n  };\r\n\r\n  function get_initial_xy (nodes, cluster_count, exclude ) { \r\n      var d_clusters = {'id': 'root', 'children': []};\r\n      for (var k = 0; k < cluster_count; k+=1) {\r\n       if (exclude != undefined && exclude[k+1] != undefined) {continue;}\r\n          d_clusters.children.push ({'cluster_id' : k+1, 'children': nodes.filter (function (v) {return v.cluster == k+1;})});\r\n      }   \r\n      \r\n      var treemap = d3.layout.treemap()\r\n      .size([self.width, self.height])\r\n      .sticky(true)\r\n      .children (function (d)  {return d.children;})\r\n      .value(function(d) { return 1;});\r\n      \r\n      return treemap.nodes (d_clusters);\r\n  }\r\n\r\n  function prepare_data_to_graph () {\r\n\r\n      var graphMe = {};\r\n      graphMe.all = [];\r\n      graphMe.edges = [];\r\n      graphMe.nodes = [];\r\n      graphMe.clusters = [];\r\n\r\n      expandedClusters = [];\r\n      drawnNodes = [];\r\n      \r\n      \r\n      self.clusters.forEach (function (x) {\r\n          // Check if hxb2_linked is in a child\r\n          var hxb2_exists = x.children.some(function(c) {return c.hxb2_linked}) && self.hide_hxb2;\r\n          if(!hxb2_exists) {\r\n            if (x.collapsed) {\r\n                graphMe.clusters.push (x);\r\n                graphMe.all.push(x);\r\n            } else {\r\n                expandedClusters[x.cluster_id] = true;\r\n            }\r\n          }\r\n      });\r\n      \r\n      self.nodes.forEach (function (x, i) {\r\n          if (expandedClusters[x.cluster]) {\r\n              drawnNodes[i] = graphMe.nodes.length +  graphMe.clusters.length;\r\n              graphMe.nodes.push(x); \r\n              graphMe.all.push(x); \r\n          } \r\n      \r\n      });\r\n      \r\n      self.edges.forEach (function (x) {\r\n\r\n          if(!(x.removed && self.filter_edges)) {\r\n            if (drawnNodes[x.source] != undefined && drawnNodes[x.target] != undefined) {\r\n\r\n                var y = {};\r\n                for (var prop in x) {\r\n                    y[prop] = x[prop];\r\n                }\r\n\r\n                y.source = drawnNodes[x.source];\r\n                y.target = drawnNodes[x.target];\r\n                graphMe.edges.push(y);\r\n            }\r\n          }\r\n      });\r\n\r\n      return graphMe;\r\n\r\n  }\r\n\r\n  function default_layout (clusters, nodes, exclude_cluster_ids) {\r\n        init_layout = get_initial_xy (nodes, self.cluster_sizes.length, exclude_cluster_ids);\r\n        clusters = init_layout.filter (function (v,i,obj) { return  !(typeof v.cluster_id === \"undefined\");});\r\n        nodes = nodes.map (function (v) {v.x += v.dx/2; v.y += v.dy/2; return v;});\r\n        clusters.forEach (collapse_cluster); \r\n        return [clusters, nodes];\r\n    }\r\n    \r\n function change_spacing (delta) {\r\n    self.charge_correction = self.charge_correction * delta;\r\n    network_layout.start ();\r\n }\r\n\r\n function change_window_size (delta, trigger) {\r\n \r\n    if (delta) {\r\n        self.width  += delta;\r\n        self.height += delta;\r\n    \r\n        self.width  = Math.min (Math.max (self.width, 200), 4000); \r\n        self.height = Math.min (Math.max (self.height, 200), 4000);\r\n    } \r\n    \r\n    network_layout.size ([self.width, self.height - 160]);\r\n    network_svg.attr (\"width\", self.width).attr (\"height\", self.height);\r\n    \r\n    if (trigger) {\r\n        network_layout.start ();       \r\n    }\r\n    \r\n }\r\n \r\n self.compute_adjacency_list = _.once(function () {    \r\n\r\n    self.nodes.forEach (function (n) {\r\n        n.neighbors = d3.set();\r\n    });\r\n    \r\n    self.edges.forEach (function (e) {\r\n        self.nodes[e.source].neighbors.add(e.target);\r\n        self.nodes[e.target].neighbors.add(e.source);\r\n    });\r\n\r\n });\r\n \r\n self.compute_local_clustering_coefficients = _.once (function () {\r\n\r\n    self.compute_adjacency_list();\r\n    \r\n    self.nodes.forEach (function (n) {\r\n        _.defer (function (a_node) {\r\n            neighborhood_size = a_node.neighbors.size ();\r\n            if (neighborhood_size < 2) {\r\n                a_node.lcc = datamonkey.hivtrace.undefined;     \r\n            } else {\r\n                if (neighborhood_size > 500) {\r\n                    a_node.lcc = datamonkey.hivtrace.too_large;     \r\n                } else {\r\n                    // count triangles\r\n                    neighborhood = a_node.neighbors.values();\r\n                    counter = 0;\r\n                    for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\r\n                        for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\r\n                            if (self.nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\r\n                                counter ++;\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\r\n                }\r\n            }\r\n            \r\n        }, n);\r\n    });\r\n\r\n });\r\n\r\n  self.get_node_by_id = function(id) {\r\n    return self.nodes.filter(function(n) {\r\n        return n.id == id;\r\n    })[0];\r\n\r\n\r\n  }\r\n\r\n self.compute_local_clustering_coefficients_worker = _.once (function () {\r\n\r\n    var worker = new Worker('workers/lcc.js');\r\n\r\n    worker.onmessage = function(event) {\r\n\r\n      var nodes = event.data.Nodes;\r\n\r\n      nodes.forEach(function(n) { \r\n        node_to_update = self.get_node_by_id(n.id);\r\n        node_to_update.lcc = n.lcc ? n.lcc : datamonkey.hivtrace.undefined;\r\n      });\r\n\r\n    };\r\n\r\n    var worker_obj = {}\r\n    worker_obj[\"Nodes\"] = self.nodes;\r\n    worker_obj[\"Edges\"] = self.edges;\r\n    worker.postMessage(worker_obj);\r\n\r\n });\r\n\r\n\r\n  \r\n  estimate_cubic_compute_cost = _.memoize(function (c) {\r\n    self.compute_adjacency_list();  \r\n    return _.reduce (_.first(_.pluck (c.children, \"degree\").sort (d3.descending),3),function (memo, value) {return memo*value;},1); \r\n  }, function (c) {return c.cluster_id;});\r\n  \r\n  self.compute_global_clustering_coefficients = _.once (function () {\r\n    self.compute_adjacency_list();\r\n \r\n    self.clusters.forEach (function (c) {\r\n         _.defer (function (a_cluster) {\r\n                cluster_size = a_cluster.children.length;\r\n                if (cluster_size < 3) {\r\n                    a_cluster.cc = datamonkey.hivtrace.undefined;     \r\n                } else {\r\n                    if (estimate_cubic_compute_cost (a_cluster, true) >= 5000000) {\r\n                        a_cluster.cc = datamonkey.hivtrace.too_large;     \r\n                    } else {\r\n                        // pull out all the nodes that have this cluster id\r\n                        member_nodes = [];\r\n                        \r\n                        var triads = 0;\r\n                        var triangles = 0; \r\n                        \r\n                        self.nodes.forEach (function (n,i) {if (n.cluster == a_cluster.cluster_id) {member_nodes.push (i);}});\r\n                        member_nodes.forEach (function (node) {\r\n                            my_neighbors = self.nodes[node].neighbors.values().map (function (d) {return +d;}).sort (d3.ascending);\r\n                            for (n1 = 0; n1 < my_neighbors.length; n1 += 1) {\r\n                                for (n2 = n1 + 1; n2 < my_neighbors.length; n2 += 1) {\r\n                                    triads += 1;\r\n                                    if (self.nodes[my_neighbors[n1]].neighbors.has (my_neighbors[n2])) {\r\n                                        triangles += 1;\r\n                                    }\r\n                                }\r\n                            }\r\n                        });\r\n                        \r\n                        a_cluster.cc = triangles/triads;\r\n                    }\r\n                }\r\n        \r\n            }, c);    \r\n        });\r\n });\r\n\r\n self.mark_nodes_as_processing = function (property) {\r\n    self.nodes.forEach (function (n) { n[property] = datamonkey.hivtrace.processing }); \r\n  }\r\n \r\n self.compute_graph_stats = function () {\r\n\r\n    d3.select (this).classed (\"disabled\", true).select(\"i\").classed ({\"fa-calculator\": false, \"fa-cog\": true, \"fa-spin\": true});\r\n    self.mark_nodes_as_processing('lcc');\r\n    self.compute_local_clustering_coefficients_worker();\r\n    self.compute_global_clustering_coefficients();\r\n    d3.select (this).remove();\r\n\r\n };\r\n\r\n\r\n  /*------------ Constructor ---------------*/\r\n  function initial_json_load() {\r\n    var connected_links = [];\r\n    var total = 0;\r\n    var exclude_cluster_ids = {};\r\n    self.has_hxb2_links = false;\r\n    self.cluster_sizes = [];\r\n\r\n    graph_data.Nodes.forEach (function (d) { \r\n          if (typeof self.cluster_sizes[d.cluster-1]  === \"undefined\") {\r\n            self.cluster_sizes[d.cluster-1] = 1;\r\n          } else {\r\n            self.cluster_sizes[d.cluster-1] ++;\r\n          }\r\n          if (\"is_lanl\" in d) {\r\n            d.is_lanl = d.is_lanl == \"true\";\r\n          }\r\n          \r\n          \r\n          if (d.attributes.indexOf (\"problematic\") >= 0) {\r\n            self.has_hxb2_links = d.hxb2_linked = true;\r\n          }\r\n      \r\n    });\r\n\r\n     /* add buttons and handlers */\r\n     /* clusters first */\r\n     \r\n     if (button_bar_ui) {\r\n     \r\n         var cluster_ui_container = d3.select (\"#\" + button_bar_ui + \"_cluster_operations_container\");\r\n         \r\n         [\r\n            [\"Expand All\",          function () {return self.expand_some_clusters()},   true, 'hivtrace-expand-all'],\r\n            [\"Collapse All\",        function () {return self.collapse_some_clusters()}, true, 'hivtrace-collapse-all'],\r\n            [\"Expand Filtered\",     function () {return self.expand_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))},   true, 'hivtrace-expand-filtered'],\r\n            [\"Collapse Filtered\",   function () {return self.collapse_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))}, true, 'hivtrace-collapse-filtered'],\r\n            [\"Hide problematic clusters\", function (item) {\r\n                                            d3.select (item).text (self.hide_hxb2 ? \"Hide problematic clusters\" :  \"Show problematic clusters\");\r\n                                            self.toggle_hxb2 ();\r\n                                          }, self.has_hxb2_links, 'hivtrace-hide-problematic-clusters'],\r\n                                          \r\n            [\"Show removed edges\",   function (item) {\r\n                                        self.filter_edges = !self.filter_edges; \r\n                                        d3.select (item).text (self.filter_edges ? \"Show removed edges\" :  \"Hide removed edges\");\r\n                                        self.update (false); \r\n                                     }\r\n                                    , function () {return _.some (self.edges, function (d) {return d.removed;});}, 'hivtrace-show-removed-edges']\r\n            \r\n         ].forEach (function (item,index) {\r\n            var handler_callback = item[1];\r\n            if (item[2]) {\r\n                this.append (\"li\").append (\"a\")\r\n                                  .text (item[0])\r\n                                  .attr (\"href\", \"#\")\r\n                                  .attr (\"id\", item[3])\r\n                                  .on (\"click\", function(e) {\r\n                                    handler_callback(this);\r\n                                    d3.event.preventDefault();\r\n                                  });\r\n            }\r\n         },cluster_ui_container);\r\n         \r\n         \r\n         var button_group  = d3.select (\"#\" + button_bar_ui + \"_button_group\");\r\n         \r\n         if (! button_group.empty()) {\r\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Expand spacing\").on (\"click\", function (d) {change_spacing (5/4);}).append (\"i\").classed (\"fa fa-arrows\", true);\r\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Compress spacing\").on (\"click\", function (d) {change_spacing (4/5);}).append (\"i\").classed (\"fa fa-arrows-alt\", true);\r\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Enlarge window\").on (\"click\", function (d) {change_window_size (20, true);}).append (\"i\").classed (\"fa fa-expand\", true);\r\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Shrink window\").on (\"click\", function (d) {change_window_size (-20, true);}).append (\"i\").classed (\"fa fa-compress\", true);\r\n\r\n            button_group.append (\"button\")\r\n              .classed(\"btn btn-default btn-sm\", true)\r\n              .attr(\"title\", \"Compute graph statistics\")\r\n              .attr(\"id\", \"hivtrace-compute-graph-statistics\")\r\n              .on(\"click\", function (d) {_.bind(self.compute_graph_stats,this)();})\r\n              .append(\"i\")\r\n              .classed(\"fa fa-calculator\", true);\r\n\r\n            button_group.append (\"button\")\r\n              .classed(\"btn btn-default btn-sm\", true)\r\n              .attr(\"title\", \"Save Image\")\r\n              .attr(\"id\", \"hivtrace-export-image\")\r\n              .on(\"click\", function(d) { datamonkey.save_image(\"png\", \"#network-svg\");})\r\n              .append (\"i\").classed (\"fa fa-image\", true);\r\n         }\r\n         \r\n         $(\"#\" + button_bar_ui + \"_filter\").on (\"input propertychange\", _.throttle (function (e) {  \r\n               var filter_value = $(this).val();\r\n               self.filter (filter_value.split (\" \").filter (function (d) {return d.length > 0;}).map (function (d) { return new RegExp (d,\"i\")}));\r\n            }, 250));\r\n        \r\n    }\r\n     \r\n    \r\n     if (attributes && \"hivtrace\" in attributes) {\r\n        attributes = attributes[\"hivtrace\"];\r\n     }\r\n     \r\n     if (attributes && \"attribute_map\" in attributes) {\r\n         /*  \r\n            map attributes into nodes and into the graph object itself using \r\n            _networkGraphAttrbuteID as the key  \r\n         */\r\n     \r\n         var attribute_map = attributes[\"attribute_map\"];\r\n     \r\n         if (\"map\" in attribute_map && attribute_map[\"map\"].length > 0) {\r\n             graph_data [_networkGraphAttrbuteID] = attribute_map[\"map\"].map (function (a,i) { return {'label': a, 'type' : null, 'values': {}, 'index' : i, 'range' : 0};});   \r\n             \r\n             graph_data.Nodes.forEach (function (n) { \r\n                n[_networkGraphAttrbuteID] = n.id.split (attribute_map[\"delimiter\"]);\r\n                n[_networkGraphAttrbuteID].forEach (function (v,i) {\r\n                    if (i < graph_data [_networkGraphAttrbuteID].length) {\r\n                        if (! (v in graph_data [_networkGraphAttrbuteID][i][\"values\"])) {\r\n                            graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = graph_data [_networkGraphAttrbuteID][i][\"range\"];\r\n                            graph_data [_networkGraphAttrbuteID][i][\"range\"] += 1;\r\n                        }\r\n                    }\r\n                    //graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = 1 + (graph_data [_networkGraphAttrbuteID][i][\"values\"][v] ? graph_data [_networkGraphAttrbuteID][i][\"values\"][v] : 0);\r\n                });\r\n            });\r\n           \r\n            graph_data [_networkGraphAttrbuteID].forEach (function (d) {\r\n                if (d['range'] < graph_data.Nodes.length && d['range'] > 1 &&d['range' ] <= 20) {\r\n                    d['type'] = 'category';\r\n                }\r\n            });\r\n            \r\n            \r\n            // populate the UI elements\r\n            if (button_bar_ui) {\r\n                var valid_cats = graph_data [_networkGraphAttrbuteID].filter (function (d) { return d['type'] == 'category'; });\r\n                //valid_cats.splice (0,0, {'label' : 'None', 'index' : -1});\r\n                               \r\n                [d3.select (\"#\" + button_bar_ui + \"_attributes\"),d3.select (\"#\" + button_bar_ui + \"_attributes_cat\")].forEach (function (m) {\r\n                \r\n                    m.selectAll (\"li\").remove();\r\n                \r\n                    var cat_menu = m.selectAll (\"li\")\r\n                                    .data([[['None',-1]],[['Categorical', -2]]].concat(valid_cats.map (function (d) {return [[d['label'],d['index']]];})));        \r\n                                                                     \r\n                    cat_menu.enter ().append (\"li\").classed (\"disabled\", function (d) {return d[0][1] < -1;});\r\n                    cat_menu.selectAll (\"a\").data (function (d) {return d;})\r\n                                            .enter ()\r\n                                            .append (\"a\")\r\n                                            .text (function (d,i,j) {return d[0];})\r\n                                            .attr (\"style\", function (d,i,j) {if (d[1] < -1) return 'font-style: italic'; if (j == 0) { return ' font-weight: bold;'}; return null; })\r\n                                            .attr ('href', '#')\r\n                                            .on (\"click\", function (d) { handle_attribute_categorical (d[1]); });\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    if (self.cluster_sizes.length > max_points_to_render) {\r\n      var sorted_array = self.cluster_sizes.map (function (d,i) { \r\n          return [d,i+1]; \r\n        }).sort (function (a,b) {\r\n          return a[0] - b[0];\r\n        });\r\n\r\n      for (var k = 0; k < sorted_array.length - max_points_to_render; k++) {\r\n          exclude_cluster_ids[sorted_array[k][1]] = 1;\r\n      }\r\n      warning_string = \"Excluded \" + (sorted_array.length - max_points_to_render) + \" clusters (maximum size \" +  sorted_array[k-1][0] + \" nodes) because only \" + max_points_to_render + \" points can be shown at once.\";\r\n    }\r\n    \r\n    // Initialize class attributes\r\n    singletons = graph_data.Nodes.filter (function (v,i) { return v.cluster === null; }).length; self.nodes = graph_data.Nodes.filter (function (v,i) { if (v.cluster && typeof exclude_cluster_ids[v.cluster]  === \"undefined\"  ) {connected_links[i] = total++; return true;} return false;  });\r\n    self.edges = graph_data.Edges.filter (function (v,i) { return connected_links[v.source] != undefined && connected_links[v.target] != undefined});\r\n    self.edges = self.edges.map (function (v,i) {v.source = connected_links[v.source]; v.target = connected_links[v.target]; v.id = i; return v;});\r\n\r\n    compute_node_degrees(self.nodes, self.edges);\r\n\r\n    var r = default_layout(self.clusters, self.nodes, exclude_cluster_ids);\r\n    self.clusters = r[0];\r\n    self.nodes = r[1];\r\n    self.clusters.forEach (function (d,i) {\r\n            cluster_mapping[d.cluster_id] = i;\r\n            d.hxb2_linked = d.children.some(function(c) {return c.hxb2_linked});\r\n            var degrees = d.children.map (function (c) {return c.degree;});\r\n            degrees.sort (d3.ascending);\r\n            d.degrees = datamonkey_describe_vector (degrees);\r\n            });\r\n     \r\n     \r\n    self.update();\r\n \r\n  }  \r\n  \r\n  function sort_table_toggle_icon (element, value) {\r\n    if (value) {\r\n        $(element).data (\"sorted\", value);\r\n        d3.select (element).selectAll (\"i\").classed (\"fa-sort-amount-desc\", value == \"desc\").classed (\"fa-sort-amount-asc\", value == \"asc\").classed (\"fa-sort\", value == \"unsorted\");\r\n    } else {\r\n        var sorted_state = $(element).data (\"sorted\");\r\n        sort_table_toggle_icon (element, sorted_state == \"asc\" ? \"desc\" : \"asc\");\r\n        return sorted_state == \"asc\" ? d3.descending: d3.ascending;\r\n    }\r\n  }\r\n  \r\n  function sort_table_by_column (element, datum) {\r\n    d3.event.preventDefault();\r\n    var table_element = $(element).closest (\"table\");\r\n    if (table_element.length) {\r\n        var sort_on             = parseInt($(element).data (\"column-id\"));\r\n        var sort_key            = $(element).data (\"sort-on\");\r\n        var sorted_state        = ($(element).data (\"sorted\"));\r\n        var sorted_function     = sort_table_toggle_icon (element);\r\n        \r\n        sort_accessor = sort_key ? function (x) {var val = x[sort_key]; if (typeof (val) === \"function\") return val (); return val;} : function (x) {return x;};\r\n        \r\n        d3.select (table_element[0]).select (\"tbody\").selectAll (\"tr\").sort (function (a,b) { return sorted_function (sort_accessor(a[sort_on]), sort_accessor(b[sort_on]));});\r\n        \r\n        // select all other elements from thead and toggle their icons\r\n        \r\n        $(table_element).find (\"thead [data-column-id]\")\r\n                        .filter (function () {return parseInt ($(this).data (\"column-id\")) != sort_on;})\r\n                        .each (function () { sort_table_toggle_icon (this, \"unsorted\");});\r\n    }\r\n  }\r\n  \r\n  function format_a_cell (data, index, item) {\r\n  \r\n     var this_sel  = d3.select (item);\r\n\r\n     current_value = typeof (data.value) === \"function\" ? data.value() : data.value;\r\n\r\n     if (\"callback\" in data) {\r\n        data.callback (item, current_value);\r\n     } else {  \r\n         var repr = \"format\" in data ?  data.format (current_value) : current_value;\r\n         if (\"html\" in data) this_sel.html (repr); else this_sel.text(repr);\r\n         if (\"sort\" in data) {\r\n            var clicker = this_sel.append (\"a\").property (\"href\", \"#\").on (\"click\", function (d) {sort_table_by_column (this, d);}).attr (\"data-sorted\", \"unsorted\").attr (\"data-column-id\", index).attr (\"data-sort-on\", data.sort);\r\n            clicker.append (\"i\").classed (\"fa fa-sort\", true).style (\"margin-left\", \"0.2em\");\r\n          }\r\n     }\r\n     if (\"help\" in data) {\r\n        this_sel.attr (\"title\", data.help);\r\n     }\r\n\r\n  }\r\n  \r\n  function add_a_sortable_table (container, headers, content) {\r\n\r\n        var thead = container.selectAll (\"thead\");\r\n        if (thead.empty()) {\r\n            thead = container.append (\"thead\");                    \r\n            thead.selectAll (\"tr\").data (headers).enter().append (\"tr\").selectAll (\"th\").data (function (d) {return d;}).enter().append (\"th\").\r\n                                  call (function (selection) { return selection.each (function (d, i) {\r\n                                        format_a_cell (d, i, this);\r\n                                    })\r\n                                  });\r\n        }  \r\n        \r\n        var tbody = container.selectAll (\"tbody\");\r\n        if (tbody.empty()) {\r\n            tbody = container.append (\"tbody\");\r\n            tbody.selectAll (\"tr\").data (content).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").call (function (selection) { return selection.each (function (d, i) {\r\n                                        handle_cluster_click \r\n                                        format_a_cell (d, i, this);\r\n                                    })\r\n                                  });\r\n        }\r\n        \r\n       \r\n  }\r\n  \r\n  \r\n  function _cluster_table_draw_buttons (element, payload) {\r\n    var this_cell = d3.select (element);\r\n    var labels = [[payload[0] ? \"collapsed\" : \"expanded\",0]];\r\n    if (payload[1]) {\r\n        labels.push ([\"problematic\",1]);\r\n    }\r\n    var buttons = this_cell.selectAll (\"button\").data (labels);\r\n    buttons.enter().append (\"button\");\r\n    buttons.exit().remove();\r\n    buttons.classed (\"btn btn-primary btn-xs\", true).text (function (d) {return d[0];})\r\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\r\n                                                 .on (\"click\", function (d) {\r\n                                                    if (d[1] == 0) {\r\n                                                        if (payload[0]) { \r\n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1], true);\r\n                                                        } else {\r\n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1]);\r\n                                                        }\r\n                                                        format_a_cell (d3.select (element).datum(), null, element);\r\n                                                    }\r\n                                                 });\r\n    \r\n  };\r\n  \r\n function _node_table_draw_buttons (element, payload) {\r\n    var this_cell = d3.select (element);\r\n    var labels = [[payload[0] ? \"shown\" : \"hidden\",0]];\r\n\r\n    var buttons = this_cell.selectAll (\"button\").data (labels);\r\n    buttons.enter().append (\"button\");\r\n    buttons.exit().remove();\r\n    buttons.classed (\"btn btn-primary btn-xs btn-node-property\", true).text (function (d) {return d[0];})\r\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\r\n                                                 .on (\"click\", function (d) {\r\n                                                    if (d[1] == 0) {\r\n                                                        if (payload[0]) { \r\n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1], true);\r\n                                                        } else {\r\n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1]);\r\n                                                        }\r\n                                                        format_a_cell (d3.select (element).datum(), null, element);\r\n                                                    }\r\n                                                 });\r\n    \r\n  };\r\n  \r\n  self.update_volatile_elements = function (container) {\r\n    container.selectAll (\"td\").filter (function (d,i) {\r\n        return (\"volatile\" in d);\r\n    }).each (function (d,i) {\r\n        format_a_cell (d, i, this);\r\n    });\r\n  };\r\n  \r\n  function draw_node_table () {\r\n\r\n    if (self.node_table) { \r\n        add_a_sortable_table (self.node_table,\r\n                                // headers\r\n                              [[{value:\"ID\", sort : \"value\", help: \"Node ID\"}, \r\n                                 {value: \"Properties\", sort: \"value\"}, \r\n                                 {value: \"Degree\", sort: \"value\", help: \"Node degree\"}, \r\n                                 {value: \"Cluster\", sort: \"value\", help: \"Which cluster does the node belong to\"}, \r\n                                 {value: \"LCC\", sort: \"value\", help: \"Local clustering coefficient\"}\r\n                               ]], \r\n                                 // rows \r\n                               self.nodes.map (function (n, i) {\r\n                                console.log(datamonkey.hivtrace.format_value(n.lcc,_defaultFloatFormat));\r\n                                return [{\"value\": n.id, help: \"Node ID\"}, \r\n                                        {       \"value\": function () {return [!self.clusters [n.cluster-1].collapsed, n.cluster]}, \r\n                                                \"callback\": _node_table_draw_buttons,\r\n                                                \"volatile\" : true\r\n                                        }, \r\n                                        {\"value\" : n.degree, help: \"Node degree\"},\r\n                                        {\"value\" : n.cluster, help: \"Which cluster does the node belong to\"}, \r\n                                        {\"value\": function () {return datamonkey.hivtrace.format_value(n.lcc,_defaultFloatFormat);},\r\n                                         \"volatile\" : true, \"html\": true, help: \"Local clustering coefficient\"}];\r\n        \r\n                                }));\r\n    }\r\n  }\r\n  \r\n  function draw_cluster_table () {\r\n    if (self.cluster_table) {\r\n        add_a_sortable_table (self.cluster_table,\r\n                                // headers\r\n                              [[{value:\"ID\", sort : \"value\", help: \"Unique cluster ID\"}, \r\n                                 {value: \"Properties\", sort: \"value\"}, \r\n                                 {value: \"Size\", sort: \"value\", help: \"Number of nodes in the cluster\"}, \r\n                                 {value: \"Degrees<br>Mean [Median, IQR]\", html : true}, \r\n                                 {value: \"CC\", sort: \"value\", help: \"Global clustering coefficient\"},\r\n                                 {value: \"MPL\", sort: \"value\", help: \"Mean Path Length\"}\r\n                               ]],\r\n                                self.clusters.map (function (d, i) {\r\n                                 // rows \r\n                                return [{value: d.cluster_id}, \r\n                                        {       value: function () {return [d.collapsed, d.hxb2_linked, d.cluster_id]}, \r\n                                                callback: _cluster_table_draw_buttons,\r\n                                                volatile : true\r\n                                        }, \r\n                                        {value :d.children.length},\r\n                                        {value : d.degrees, format: function (d) {return _defaultFloatFormat(d['mean']) + \" [\" + _defaultFloatFormat(d['median']) + \", \" + _defaultFloatFormat(d['Q1']) + \" - \" + _defaultFloatFormat(d['Q3']) +\"]\"}}, \r\n                                        {\r\n                                            value: function () {return hivtrace_format_value(d.cc,_defaultFloatFormat);},\r\n                                            volatile : true, \r\n                                            help: \"Global clustering coefficient\"\r\n                                        },\r\n                                        {\r\n                                            value: function () {return hivtrace_format_value(d.mpl,_defaultFloatFormat);},\r\n                                            volatile : true, \r\n                                            help: \"Mean path length\"\r\n                                        }\r\n                                        ];\r\n        \r\n                                })\r\n                                );\r\n        }     \r\n  }\r\n\r\n  /*------------ Update layout code ---------------*/\r\n  function update_network_string (draw_me) {\r\n      if (network_status_string) {\r\n          var clusters_shown = self.clusters.length-draw_me.clusters.length,\r\n              clusters_removed = self.cluster_sizes.length - self.clusters.length,\r\n              nodes_removed = graph_data.Nodes.length - singletons - self.nodes.length;\r\n          \r\n          var s = \"Displaying a network on <strong>\" + self.nodes.length + \"</strong> nodes, <strong>\" + self.clusters.length + \"</strong> clusters\"\r\n                  + (clusters_removed > 0 ? \" (an additional \" + clusters_removed + \" clusters and \" + nodes_removed + \" nodes have been removed due to network size constraints)\" : \"\") + \". <strong>\" \r\n                  + clusters_shown +\"</strong> clusters are expanded. Of <strong>\" + self.edges.length + \"</strong> edges, <strong>\" + draw_me.edges.length + \"</strong>, and of  <strong>\" + self.nodes.length  + \" </strong> nodes,  <strong>\" + draw_me.nodes.length + \" </strong> are displayed. \";\r\n          if (singletons > 0) {\r\n              s += \"<strong>\" +singletons + \"</strong> singleton nodes are not shown. \";\r\n          }\r\n          d3.select (network_status_string).html(s);\r\n    }\r\n  }\r\n\r\n  \r\n  function draw_a_node (container, node) {\r\n    container = d3.select(container);\r\n    container.attr(\"d\", d3.svg.symbol().size( node_size )\r\n        .type( function(d) { return (d.hxb2_linked && !d.is_lanl) ? \"cross\" : (d.is_lanl ? \"triangle-down\" : \"circle\") }))\r\n        .attr('class', 'node')\r\n        .attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\r\n        .style('fill', function(d) { return node_color(d); })\r\n        .on ('click', handle_node_click)\r\n        .on ('mouseover', node_pop_on)\r\n        .on ('mouseout', node_pop_off)\r\n        .call(network_layout.drag().on('dragstart', node_pop_off));\r\n  }\r\n    \r\n\r\n  function draw_a_cluster (container, the_cluster) {\r\n       \r\n     container_group = d3.select(container);\r\n     \r\n     \r\n     var draw_from   = the_cluster[\"binned_attributes\"] ? the_cluster[\"binned_attributes\"].map (function (d) {return d.concat ([0]);}) : [[null, 1, 0]];\r\n         \r\n     if (the_cluster.match_filter) {\r\n        draw_from = draw_from.concat ([[\"selected\",the_cluster.match_filter,1],[\"not selected\",the_cluster.children.length - the_cluster.match_filter,1]]);\r\n     }\r\n\r\n     var sums  = [d3.sum(draw_from.filter (function (d) {return d[2] == 0}),function (d) {return d[1];}),\r\n                  d3.sum(draw_from.filter (function (d) {return d[2] != 0}),function (d) {return d[1];})];\r\n                 \r\n     var running_totals = [0,0];\r\n\r\n     draw_from = draw_from.map (function (d) {  index = d[2];\r\n                                                var v = {'container' : container, \r\n                                                        'cluster': the_cluster, \r\n                                                        'startAngle' : running_totals[index]/sums[index]*2*Math.PI, \r\n                                                        'endAngle': (running_totals[index]+d[1])/sums[index]*2*Math.PI, \r\n                                                        'name': d[0],\r\n                                                        'rim' : index > 0}; \r\n                                                 running_totals[index] += d[1]; \r\n                                                 return v;\r\n                                                 \r\n                                             });\r\n     \r\n     \r\n     var arc_radius = cluster_box_size(the_cluster)*0.5;\r\n     var paths = container_group.selectAll (\"path\").data (draw_from);\r\n     paths.enter ().append (\"path\");\r\n     paths.exit  ().remove();\r\n     \r\n     paths.classed (\"cluster\", true)\r\n          .classed (\"hiv-trace-problematic\", function (d) {return the_cluster.hxb2_linked && !d.rim;})\r\n          .classed (\"hiv-trace-selected\", function (d) {return d.rim;})\r\n          .attr (\"d\", function (d) {\r\n                return (d.rim \r\n                        ? d3.svg.arc().innerRadius(arc_radius+2).outerRadius(arc_radius+5)\r\n                        : d3.svg.arc().innerRadius(0).outerRadius(arc_radius))(d);\r\n                })\r\n          .style (\"fill\", function (d,i) {return d.rim ? self.colorizer ['selected'] (d.name) : cluster_color (the_cluster, d.name);})\r\n          ;\r\n    \r\n     \r\n     \r\n  }\r\n  \r\n  function handle_attribute_categorical (cat_id) {\r\n  \r\n    var set_attr = \"None\";\r\n\r\n    [\"#\" + button_bar_ui + \"_attributes\",\"#\" + button_bar_ui + \"_attributes_cat\"].forEach (function (m) {\r\n        d3.select (m).selectAll (\"li\")\r\n                                                       .selectAll (\"a\")\r\n                                                       .attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\r\n      \r\n        d3.select (m + \"_label\").html (set_attr + ' <span class=\"caret\"></span>');\r\n    });\r\n                                                   \r\n\r\n\r\n     self.clusters.forEach (function (the_cluster) {the_cluster['binned_attributes'] = stratify(attribute_cluster_distribution (the_cluster, cat_id));});\r\n    \r\n     if (cat_id >= 0) {\r\n        self.colorizer['category']    = graph_data [_networkGraphAttrbuteID][cat_id]['range'] <= 10 ? d3.scale.category10() : d3.scale.category20c();\r\n        self.colorizer['category_id'] = cat_id;  \r\n        self.colorizer['category_map'] = graph_data [_networkGraphAttrbuteID][cat_id]['values'];\r\n        self.colorizer['category_map'][null] =  graph_data [_networkGraphAttrbuteID][cat_id]['range'];\r\n        self.colorizer['category_pairwise'] = attribute_pairwise_distribution(cat_id, graph_data [_networkGraphAttrbuteID][cat_id]['range'] + 1, self.colorizer['category_map']);\r\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\r\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribute_table\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\r\n    } else {\r\n        self.colorizer['category']          = null;\r\n        self.colorizer['category_id']       = null;\r\n        self.colorizer['category_pairwise'] = null;\r\n        self.colorizer['category_map']      = null;\r\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\r\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribite_table\", null, null);\r\n    }\r\n    \r\n    console.log (self.colorizer, graph_data [_networkGraphAttrbuteID]);\r\n\r\n    self.update(true);\r\n    d3.event.preventDefault();\r\n  }\r\n  \r\n  self.filter = function (expressions, skip_update) {\r\n  \r\n    var anything_changed = false;\r\n    \r\n    self.clusters.forEach (function (c) {\r\n        c.match_filter = 0;\r\n    });\r\n    \r\n    self.nodes.forEach (function (n) {\r\n        var did_match = _.some(expressions, function (regexp) {    \r\n            return regexp.test (n.id)  ;\r\n        });\r\n        \r\n        if (did_match != n.match_filter) {\r\n            n.match_filter = did_match;\r\n            anything_changed = true;\r\n        }\r\n        \r\n        if (n.match_filter) {\r\n            n.parent.match_filter += 1;\r\n        }\r\n    });\r\n    \r\n    \r\n    if (anything_changed && !skip_update) {\r\n        self.update (true);\r\n    }\r\n    \r\n  }\r\n  \r\n  self.update = function (soft, friction) {\r\n  \r\n    self.needs_an_update = false;\r\n  \r\n    if (friction) {\r\n        network_layout.friction (friction);\r\n    }\r\n    if (network_warning_tag) {\r\n        if (warning_string.length) {\r\n          d3.select (network_warning_tag).text (warning_string).style (\"display\", \"block\");\r\n          warning_string = \"\";\r\n        } else {\r\n          d3.select (network_warning_tag).style (\"display\", \"none\");  \r\n        }\r\n    }\r\n\r\n    var rendered_nodes, \r\n        rendered_clusters,\r\n        link;\r\n        \r\n    if (!soft) {\r\n\r\n        var draw_me = prepare_data_to_graph(); \r\n        \r\n\r\n        network_layout.nodes(draw_me.all)\r\n            .links(draw_me.edges)\r\n            .start ();\r\n        \r\n        update_network_string(draw_me);\r\n        \r\n        link = network_svg.selectAll(\".link\")\r\n            .data(draw_me.edges, function (d) {return d.id;});\r\n        \r\n        var link_enter = link.enter().append(\"line\")\r\n            .classed (\"link\", true)\r\n            .classed (\"removed\", function (d) {return d.removed;})\r\n            .classed (\"unsupported\", function (d) { return \"support\" in d && d[\"support\"] > 0.05;})\r\n            .on (\"mouseover\", edge_pop_on)\r\n            .on (\"mouseout\", edge_pop_off)\r\n            .filter (function (d) {return d.directed;})\r\n            .attr(\"marker-end\", \"url(#arrowhead)\");\r\n\r\n        link.exit().remove();\r\n\r\n        rendered_nodes  = network_svg.selectAll('.node')\r\n            .data(draw_me.nodes, function (d) {return d.id;});\r\n        rendered_nodes.exit().remove();\r\n        rendered_nodes.enter().append(\"path\");\r\n        \r\n        rendered_clusters = network_svg.selectAll (\".cluster-group\").\r\n          data(draw_me.clusters.map (function (d) {return d;}), function (d) {return d.cluster_id;});\r\n \r\n        rendered_clusters.exit().remove();\r\n        rendered_clusters.enter().append (\"g\").attr (\"class\", \"cluster-group\")\r\n              .attr (\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\r\n              .on (\"click\", handle_cluster_click)\r\n              .on (\"mouseover\", cluster_pop_on)\r\n              .on (\"mouseout\", cluster_pop_off)\r\n              .call(network_layout.drag().on(\"dragstart\", cluster_pop_off));\r\n        \r\n        draw_cluster_table();\r\n        draw_node_table();\r\n    \r\n    } else {\r\n        rendered_nodes = network_svg.selectAll('.node');\r\n        rendered_clusters = network_svg.selectAll (\".cluster-group\");\r\n        link = network_svg.selectAll(\".link\");\r\n    }\r\n\r\n    rendered_nodes.each (function (d) { \r\n              draw_a_node (this, d);\r\n             });  \r\n          \r\n    rendered_clusters.each (function (d) {\r\n        draw_a_cluster (this, d);\r\n    });\r\n    \r\n     \r\n    if (!soft) {\r\n        currently_displayed_objects = rendered_clusters[0].length + rendered_nodes[0].length;\r\n\r\n        network_layout.on(\"tick\", function() {\r\n        \r\n          link.attr(\"x1\", function(d) { return d.source.x; })\r\n              .attr(\"y1\", function(d) { return d.source.y; })\r\n              .attr(\"x2\", function(d) { return d.target.x; })\r\n              .attr(\"y2\", function(d) { return d.target.y; });\r\n\r\n          rendered_nodes.attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; });\r\n          rendered_clusters.attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; });\r\n        });    \r\n    }\r\n  }\r\n\r\n  function tick() {\r\n    link.attr(\"x1\", function(d) { return d.source.x; })\r\n        .attr(\"y1\", function(d) { return d.source.y; })\r\n        .attr(\"x2\", function(d) { return d.target.x; })\r\n        .attr(\"y2\", function(d) { return d.target.y; });\r\n\r\n    node.attr(\"cx\", function(d) { return d.x; })\r\n        .attr(\"cy\", function(d) { return d.y; });\r\n  }\r\n\r\n  /*------------ Node Methods ---------------*/\r\n  function compute_node_degrees(nodes, edges) {\r\n      for (var n in nodes) {\r\n          nodes[n].degree = 0;\r\n      }\r\n      \r\n      for (var e in edges) {\r\n          nodes[edges[e].source].degree++;\r\n          nodes[edges[e].target].degree++;\r\n      }\r\n  }\r\n\r\n    \r\n  function  attribute_node_value_by_id (d, id) {\r\n     if (_networkGraphAttrbuteID in d ) {\r\n        if (id) {\r\n            return d[_networkGraphAttrbuteID][id];\r\n        }\r\n     }\r\n     return null;\r\n  }\r\n  \r\n  function  attribute_name_by_id (id) {\r\n    if (typeof id == \"number\") {\r\n        return graph_data [_networkGraphAttrbuteID][id]['label'];\r\n    }\r\n    return null;\r\n  }\r\n  \r\n  function node_size (d) {\r\n    var r = 3+Math.sqrt(d.degree); return (d.match_filter ? 10 : 4)*r*r; \r\n  }\r\n\r\n  function node_color(d) {\r\n    \r\n    if (d.match_filter) {\r\n        return \"white\";\r\n    }\r\n  \r\n    var color = attribute_node_value_by_id (d, self.colorizer['category_id']);\r\n    if (color) {\r\n        return self.colorizer['category'](color);\r\n    }\r\n    return d.hxb2_linked ? \"black\" : (d.is_lanl ? \"red\" : \"#7fc97f\");\r\n  }\r\n\r\n  function cluster_color(d, type) {\r\n    if (d[\"binned_attributes\"]) {\r\n        return self.colorizer['category'](type);\r\n    }\r\n    return \"#bdbdbd\";\r\n  }\r\n\r\n  function hxb2_node_color(d) {\r\n    return \"black\";\r\n  }\r\n\r\n  function node_info_string (n) {\r\n      var str = \"Degree <em>\" + n.degree + \"</em>\"+\r\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (n.lcc, _defaultFloatFormat) + \"</em>\";\r\n                 \r\n      var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\r\n      if (attribute) {\r\n         str += \"<br>\"  + attribute_name_by_id (self.colorizer['category_id']) + \" <em>\" + attribute + \"</em>\"\r\n      }\r\n      return str;\r\n  }\r\n\r\n  function edge_info_string (n) {\r\n     var str = \"Length <em>\" + _defaultFloatFormat(n.length) + \"</em>\";\r\n     if (\"support\" in n) {\r\n        str += \"<br>Worst triangle-based support (p): <em>\" + _defaultFloatFormat(n.support) + \"</em>\";\r\n     }\r\n                 \r\n      var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\r\n\r\n      return str;\r\n  }\r\n\r\n  function node_pop_on (d) {\r\n      toggle_tooltip (this, true, \"Node \" + d.id, node_info_string (d));\r\n  }\r\n\r\n  function node_pop_off (d) {\r\n      toggle_tooltip (this, false);\r\n  }\r\n\r\n  function edge_pop_on (e) {\r\n      toggle_tooltip (this, true, e.source.id + \" - \" + e.target.id, edge_info_string (e));\r\n  }\r\n\r\n  function edge_pop_off (d) {\r\n      toggle_tooltip (this, false);\r\n  }\r\n\r\n\r\n  /*------------ Cluster Methods ---------------*/\r\n\r\n  function compute_cluster_centroids (clusters) {\r\n      for (var c in clusters) {\r\n          var cls = clusters[c];\r\n          cls.x = 0.;\r\n          cls.y = 0.;\r\n          cls.children.forEach (function (x) { cls.x += x.x; cls.y += x.y; });\r\n          cls.x /= cls.children.length;\r\n          cls.y /= cls.children.length;\r\n      }\r\n  }\r\n\r\n  function collapse_cluster(x, keep_in_q) {\r\n      self.needs_an_update = true;\r\n      x.collapsed = true;\r\n      currently_displayed_objects -= self.cluster_sizes[x.cluster_id-1]-1;\r\n      if (!keep_in_q) {\r\n          var idx = open_cluster_queue.indexOf(x.cluster_id);\r\n          if (idx >= 0) {\r\n           open_cluster_queue.splice (idx,1);\r\n          }\r\n      }\r\n      compute_cluster_centroids ([x]);\r\n      return x.children.length;\r\n  }\r\n\r\n  function expand_cluster (x, copy_coord) {\r\n      self.needs_an_update = true;\r\n      x.collapsed = false;\r\n      currently_displayed_objects += self.cluster_sizes[x.cluster_id-1]-1;\r\n      open_cluster_queue.push (x.cluster_id);\r\n      if (copy_coord) {\r\n          x.children.forEach (function (n) { n.x = x.x + (Math.random()-0.5)*x.children.length; n.y = x.y + (Math.random()-0.5)*x.children.length; });\r\n      } else {\r\n          x.children.forEach (function (n) { n.x = self.width * 0.25 + (Math.random()-0.5)*x.children.length; n.y = 0.25*self.height + (Math.random()-0.5)*x.children.length; })\r\n      }\r\n  }\r\n\r\n  function render_binned_table (id, the_map, matrix) {\r\n  \r\n    var the_table = d3.select (id);\r\n  \r\n    the_table.selectAll (\"thead\").remove();\r\n    the_table.selectAll (\"tbody\").remove();\r\n    \r\n    if (matrix) {\r\n        \r\n        var fill = self.colorizer['category'];\r\n        lookup = _.invert (the_map);\r\n        \r\n        \r\n        var headers = the_table.append (\"thead\").append (\"tr\")\r\n                      .selectAll (\"th\").data ([\"\"].concat (matrix[0].map (function (d,i) {return lookup [i];})));\r\n                      \r\n        headers.enter().append (\"th\");\r\n        headers.html (function (d) { return \"<span>&nbsp;\" + d + \"</span>\";}).each (\r\n            function (d,i) {\r\n                if (i) {\r\n                    d3.select (this).insert (\"i\",\":first-child\")\r\n                        .classed (\"fa fa-circle\", true)\r\n                        .style (\"color\", function () {return fill (d);});\r\n                }\r\n            }\r\n        );\r\n\r\n        var rows = the_table.append (\"tbody\").selectAll (\"tr\").data (matrix.map (function (d, i) {return [lookup[i]].concat (d);}));\r\n        rows.enter ().append (\"tr\");\r\n        rows.selectAll (\"td\").data (function (d) {return d}).enter().append (\"td\").html (function (d, i) {\r\n            return i == 0 ? (\"<span>&nbsp;\" + d + \"</span>\") : d;\r\n        }).each (function (d, i) {\r\n                if (i == 0) {\r\n                    d3.select (this).insert (\"i\",\":first-child\")\r\n                        .classed (\"fa fa-circle\", true)\r\n                        .style (\"color\", function () {return fill (d);});\r\n                }\r\n        \r\n        });\r\n                      \r\n        \r\n\r\n    }\r\n  }\r\n  \r\n  function render_chord_diagram (id, the_map, matrix) {\r\n         \r\n        d3.select (id).selectAll (\"svg\").remove();\r\n        if (matrix) {\r\n        \r\n            lookup = _.invert (the_map);\r\n            \r\n  \r\n            var svg = d3.select (id).append (\"svg\");\r\n        \r\n        \r\n            var chord = d3.layout.chord()\r\n                .padding(.05)\r\n                .sortSubgroups(d3.descending)\r\n                .matrix(matrix);\r\n\r\n            var text_offset = 20,\r\n                width  = 450,\r\n                height = 450,\r\n                innerRadius = Math.min(width, height-text_offset) * .41,\r\n                outerRadius = innerRadius * 1.1;\r\n\r\n            var fill = self.colorizer['category'],\r\n                font_size = 12;\r\n        \r\n        \r\n        \r\n            var text_label = svg.append (\"g\")\r\n                                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset)  + \")\")\r\n                                .append (\"text\")\r\n                                .attr (\"text-anchor\", \"middle\")\r\n                                .attr (\"font-size\", font_size)\r\n                                .text (\"\");\r\n\r\n            svg = svg.attr(\"width\", width)\r\n                .attr(\"height\", height-text_offset)\r\n                .append(\"g\")\r\n                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset) / 2 + \")\");\r\n            \r\n    \r\n            svg.append(\"g\").selectAll(\"path\")\r\n                .data(chord.groups)\r\n              .enter().append(\"path\")\r\n                .style(\"fill\", function(d)   { return fill(lookup[d.index]); })\r\n                .style(\"stroke\", function(d) { return fill(lookup[d.index]); })\r\n                .attr(\"d\", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))\r\n                .on(\"mouseover\", fade(0.1,true))\r\n                .on(\"mouseout\", fade(1,false));\r\n\r\n        \r\n\r\n            svg.append(\"g\")\r\n                .attr(\"class\", \"chord\")\r\n              .selectAll(\"path\")\r\n                .data(chord.chords)\r\n              .enter().append(\"path\")\r\n                .attr(\"d\", d3.svg.chord().radius(innerRadius))\r\n                .style(\"fill\", function(d) { return fill(d.target.index); })\r\n                .style(\"opacity\", 1);\r\n\r\n            // Returns an event handler for fading a given chord group.\r\n            function fade(opacity,t) {\r\n              return function(g, i) {\r\n                text_label.text (t ? lookup[i] : \"\");\r\n                svg.selectAll(\".chord path\")\r\n                    .filter(function(d) { return d.source.index != i && d.target.index != i; })\r\n                  .transition()\r\n                    .style(\"opacity\", opacity);\r\n              };\r\n            }\r\n        }\r\n  }\r\n\r\n  function attribute_pairwise_distribution (id, dim, the_map, only_expanded) {\r\n        var scan_from = only_expanded ? draw_me.edges : self.edges;\r\n        var the_matrix = [];\r\n        for (i = 0 ; i < dim; i+=1) {\r\n            the_matrix.push([]);\r\n            for (j = 0; j < dim; j += 1){\r\n                the_matrix[i].push (0);\r\n            }\r\n        }  \r\n        scan_from.forEach (function (edge) { the_matrix[the_map[attribute_node_value_by_id(self.nodes[edge.source], id)]][the_map[attribute_node_value_by_id(self.nodes[edge.target], id)]] += 1;});\r\n        // check if there are null values\r\n        \r\n        var haz_null = the_matrix.some (function (d, i) { if (i == dim - 1) {return d.some (function (d2) {return d2 > 0;});} return d[dim-1] > 0;});\r\n        if (!haz_null) {\r\n            the_matrix.pop();\r\n            for (i = 0 ; i < dim - 1; i+=1) {\r\n                the_matrix[i].pop();\r\n            }\r\n        }\r\n        \r\n        return the_matrix;\r\n  }\r\n    \r\n  function attribute_cluster_distribution (the_cluster, attribute_id) {\r\n        if (attribute_id >= 0 && the_cluster) {\r\n            return the_cluster.children.map (function (d) {return (_networkGraphAttrbuteID in d) ? d[_networkGraphAttrbuteID][attribute_id] : null;});\r\n        }\r\n        return null;\r\n  }\r\n\r\n  function cluster_info_string (id) {\r\n      var the_cluster = self.clusters[id-1],\r\n          attr_info = the_cluster[\"binned_attributes\"];\r\n          \r\n          \r\n\r\n      var str = \"<strong>\" + self.cluster_sizes[id-1] + \"</strong> nodes.\" + \r\n             \"<br>Mean degree <em>\" + _defaultFloatFormat(the_cluster.degrees['mean']) + \"</em>\" +\r\n             \"<br>Max degree <em>\" + the_cluster.degrees['max'] + \"</em>\" +\r\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (the_cluster.cc, _defaultFloatFormat) + \"</em>\";\r\n      \r\n      if (attr_info) {\r\n            attr_info.forEach (function (d) { str += \"<br>\" + d[0] + \" <em>\" + d[1] + \"</em>\"});\r\n      }\r\n             \r\n      return str;\r\n  }\r\n\r\n  function cluster_pop_on (d) {\r\n      toggle_tooltip (this, true, \"Cluster \" + d.cluster_id, cluster_info_string (d.cluster_id));\r\n  }\r\n\r\n  function cluster_pop_off (d) {\r\n      toggle_tooltip (this, false);\r\n  }\r\n\r\n  function expand_cluster_handler (d, do_update, move_out) {\r\n    if (d.collapsed) {  \r\n        var new_nodes = self.cluster_sizes[d.cluster_id-1] - 1;\r\n        \r\n        if (new_nodes > max_points_to_render) {\r\n            warning_string = \"This cluster is too large to be displayed\";\r\n        }\r\n        else {\r\n            var leftover = new_nodes + currently_displayed_objects - max_points_to_render;\r\n            if (leftover > 0) {\r\n              for (k = 0; k < open_cluster_queue.length && leftover > 0; k++) {\r\n                  var cluster = self.clusters[cluster_mapping[open_cluster_queue[k]]];\r\n                  leftover -= cluster.children.length - 1;\r\n                  collapse_cluster(cluster,true);\r\n              }\r\n              if (k || open_cluster_queue.length) {\r\n                  open_cluster_queue.splice (0, k);\r\n              }\r\n            }\r\n    \r\n            if (leftover <= 0) {\r\n                expand_cluster (d, !move_out);\r\n            }\r\n        }\r\n            \r\n        if (do_update) {\r\n            self.update(false, 0.6);\r\n        }\r\n    }\r\n    return \"\";\r\n  }\r\n\r\n  function collapse_cluster_handler (d, do_update) {\r\n    collapse_cluster(self.clusters[cluster_mapping[d.cluster]]);\r\n    if (do_update) {       \r\n        self.update(false, 0.4);\r\n    }\r\n    \r\n  }\r\n\r\n  function center_cluster_handler (d) {\r\n    d.x = self.width/2;\r\n    d.y = self.height/2;\r\n    self.update(false, 0.4);\r\n  }\r\n\r\n  function cluster_box_size (c) {\r\n      return 5*Math.sqrt (c.children.length);\r\n  }\r\n\r\n  self.expand_some_clusters = function(subset)  {\r\n    subset = subset || self.clusters;\r\n    subset.forEach (function (x) { expand_cluster_handler (x, false); });\r\n    self.update (); \r\n  }\r\n  \r\n  self.select_some_clusters = function (condition) {\r\n    return self.clusters.filter (function (c, i) {\r\n        return _.some(c.children, (function (n) {return condition (n);}));\r\n    });\r\n  }\r\n\r\n  self.collapse_some_clusters = function(subset) {\r\n    subset = subset || self.clusters;\r\n    subset.forEach (function (x) { if (!x.collapsed) collapse_cluster (x); });\r\n    self.update();\r\n  }\r\n\r\n  self.toggle_hxb2 = function()  {\r\n    self.hide_hxb2 = !self.hide_hxb2;\r\n    self.update();\r\n  }\r\n\r\n  $('#reset_layout').click(function(e) {\r\n    default_layout(clusters, nodes);\r\n    self.update ();\r\n    e.preventDefault();// prevent the default anchor functionality\r\n    });\r\n\r\n  function stratify (array) {\r\n    if (array) {\r\n        var dict = {},\r\n            stratified = [];\r\n        \r\n        array.forEach (function (d) { if (d in dict) {dict[d] += 1;} else {dict[d] = 1;}});\r\n        for (var uv in dict) {\r\n            stratified.push ([uv, dict[uv]]);\r\n        }\r\n        return stratified.sort (function (a,b) {\r\n              return a[0] - b[0];\r\n            });\r\n     }\r\n     return array;\r\n   }\r\n\r\n  /*------------ Event Functions ---------------*/\r\n  function toggle_tooltip(element, turn_on, title, tag) {\r\n    //if (d3.event.defaultPrevented) return;\r\n    if (turn_on && !element.tooltip) {\r\n    \r\n      // check to see if there are any other tooltips shown\r\n     ($(\"[role='tooltip']\")).each (function (d) {\r\n        $(this).remove();\r\n     });\r\n    \r\n      var this_box = $(element);\r\n      var this_data = d3.select(element).datum();\r\n      element.tooltip = this_box.tooltip({\r\n                 title: title + \"<br>\" + tag,\r\n                 html: true,\r\n                 container: 'body',\r\n               });\r\n               \r\n      //this_data.fixed = true;\r\n      \r\n      _.delay (_.bind(element.tooltip.tooltip, element.tooltip), 500, 'show');\r\n    } else {\r\n      if (turn_on == false && element.tooltip) {\r\n        element.tooltip.tooltip('destroy');\r\n        element.tooltip = undefined;\r\n      }\r\n    }\r\n  }\r\n  initial_json_load();       \r\n  return self;\r\n}\r\n\r\n\r\n\r\nvar hivtrace_cluster_graph_summary = function (graph, tag) {\r\n \r\n    var summary_table = d3.select (tag).append (\"tbody\");\r\n    \r\n    var table_data = [];\r\n    \r\n    if (!summary_table.empty()) {\r\n        _.each (graph[\"Network Summary\"], function (value, key) {\r\n            table_data.push ([key, value]);\r\n        });\r\n    }\r\n    \r\n    var degrees = [];\r\n    _.each (graph [\"Degrees\"][\"Distribution\"], function (value, index) { for (k = 0; k < value; k++) {degrees.push (index+1);}});    \r\n    degrees = datamonkey.helpers.describe_vector (degrees);\r\n    table_data.push (['Degrees', '']);\r\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\r\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\r\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\r\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\r\n\r\n    degrees = datamonkey.helpers.describe_vector (graph [\"Cluster sizes\"]);\r\n    table_data.push (['Cluster sizes', '']);\r\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\r\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\r\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\r\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\r\n    \r\n    \r\n    summary_table.selectAll (\"tr\").data (table_data).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").html (function (d) {return d});\r\n}\r\n\r\ndatamonkey.hivtrace.cluster_network_graph = hivtrace_cluster_network_graph;\r\ndatamonkey.hivtrace.graph_summary = hivtrace_cluster_graph_summary;\r\n"],"sourceRoot":"/source/"}