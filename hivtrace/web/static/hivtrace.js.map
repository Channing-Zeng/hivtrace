{"version":3,"sources":["main.js","misc.js","histogram.js","clusternetwork.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACniBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hivtrace.js","sourcesContent":["var root = this;\n\ndatamonkey.hivtrace = function () {};\n\nif (typeof exports !== 'undefined') {\n\n  if (typeof module !== 'undefined' && module.exports) {\n    exports = module.exports = datamonkey.hivtrace;\n  }\n\n  exports.datamonkey.hivtrace = datamonkey.hivtrace;\n\n} else {\n\n  root.datamonkey.hivtrace = datamonkey.hivtrace;\n\n}\n","//_ = require('underscore');\n\nfunction hivtrace_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var adjacency_list = {};\n\n    edges.forEach(function(e, i) {\n\n        function in_nodes(n, id) {\n            return n.id == id;\n        }\n\n        var seq_ids = e[\"sequences\"];\n\n        var n1 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[0])\n            })[0],\n            n2 = nodes.filter(function(n) {\n                return in_nodes(n, seq_ids[1])\n            })[0];\n\n        adjacency_list[n1.id] ? adjacency_list[n1.id].push(n2) : adjacency_list[n1.id] = [n2];\n        adjacency_list[n2.id] ? adjacency_list[n2.id].push(n1) : adjacency_list[n2.id] = [n1];\n\n    });\n\n\n    return adjacency_list;\n\n}\n\n\nfunction hivtrace_new_cluster_adjacency_list(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    nodes.forEach (function (n) {\n        n.neighbors = d3.set();\n    });\n    \n    edges.forEach (function (e) {\n        nodes[e.source].neighbors.add(e.target);\n        nodes[e.target].neighbors.add(e.source);\n    });\n\n}\n\n// Reconstructs path from floyd-warshall algorithm\nfunction hivtrace_get_path(next, i, j) {\n\n    var all_paths = [];\n    var i = parseInt(i);\n    var j = parseInt(j);\n\n    for (var c = 0; c < next[i][j].length; c++) {\n\n        var k = next[i][j][c];\n        var intermediate = k;\n\n        if (intermediate == null || intermediate == i) {\n            return [\n                [parseInt(i), parseInt(j)]\n            ];\n        } else {\n\n            var paths_i_k = hivtrace_get_path(next, i, intermediate);\n            var paths_k_j = hivtrace_get_path(next, intermediate, j);\n\n            for (var i_k_index = 0; i_k_index < paths_i_k.length; i_k_index++) {\n                var i_k = paths_i_k[i_k_index];\n                for (var k_j_index = 0; k_j_index < paths_k_j.length; k_j_index++) {\n                    var k_j = paths_k_j[k_j_index];\n                    if (i_k.length) {\n                        if ((i_k[0] == i) && (i_k[i_k.length - 1] == k) && (k_j[0] == k) && (k_j[k_j.length - 1] == j)) {\n                            i_k.pop()\n                            all_paths.push(i_k.concat(k_j));\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return all_paths;\n\n}\n\nfunction hivtrace_paths_with_node(node, next, i, j) {\n\n    var paths = hivtrace_get_path(next, i, j);\n\n    // Retrieve intermediary paths\n    paths = paths.map(function(sublist) {\n        return sublist.slice(1, -1)\n    });\n\n    if (!paths) {\n        return 0;\n    }\n\n    var num_nodes = [];\n\n    for (var i = 0; i < paths.length; i++) {\n        sublist = paths[i];\n        num_nodes.push(d3.sum(sublist.map(function(n) {\n            return n == node;\n        })));\n    }\n\n    var mean = d3.mean(num_nodes);\n\n    if (mean == undefined) {\n        mean = 0;\n    }\n\n    return mean;\n\n}\n\n\n// Same as compute shortest paths, but with an additional next parameter for reconstruction\nfunction hivtrace_compute_shortest_paths_with_reconstruction(obj, subset, use_actual_distances) {\n\n    // Floyd-Warshall implementation\n    var distances = [];\n    var next = [];\n    var nodes = obj.Nodes;\n    var edges = obj.Edges;\n    var node_ids = [];\n\n    var adjacency_list = datamonkey.hivtrace.cluster_adjacency_list(obj);\n\n    if (!subset) {\n        subset = Object.keys(adjacency_list);\n    }\n\n    var node_count = subset.length;\n\n    for (var i = 0; i < subset.length; i++) {\n        var a_node = subset[i];\n        var empty_arr = _.range(node_count).map(function(d) {\n            return null\n        });\n        var zeroes = _.range(node_count).map(function(d) {\n            return null\n        });\n        distances.push(zeroes);\n        next.push(empty_arr);\n    };\n\n    for (var index = 0; index < subset.length; index++) {\n        var a_node = subset[index];\n        for (var index2 = 0; index2 < subset.length; index2++) {\n            var second_node = subset[index2];\n            if (second_node != a_node) {\n                if (adjacency_list[a_node].map(function(n) {\n                        return n.id\n                    }).indexOf(second_node) != -1) {\n                    distances[index][index2] = 1;\n                    distances[index2][index] = 1;\n                }\n            }\n        }\n    }\n\n    for (var index_i = 0; index_i < subset.length; index_i++) {\n        var n_i = subset[index_i];\n        for (var index_j = 0; index_j < subset.length; index_j++) {\n            var n_j = subset[index_j];\n            if (index_i == index_j) {\n                next[index_i][index_j] = [];\n            } else {\n                next[index_i][index_j] = [index_i];\n            }\n        }\n    }\n\n    // clone distances\n    var distances2 = _.map(distances, _.clone);\n    var c = 0;\n\n    for (var index_k = 0; index_k < subset.length; index_k++) {\n        var n_k = subset[index_k];\n        for (var index_i = 0; index_i < subset.length; index_i++) {\n            var n_i = subset[index_i];\n            for (var index_j = 0; index_j < subset.length; index_j++) {\n                var n_j = subset[index_j];\n\n                if (n_i != n_j) {\n\n                    d_ik = distances[index_k][index_i];\n                    d_jk = distances[index_k][index_j];\n                    d_ij = distances[index_i][index_j];\n\n                    if (d_ik != null && d_jk != null) {\n                        d_ik += d_jk;\n                        if (d_ij == null || (d_ij > d_ik)) {\n                            distances2[index_i][index_j] = d_ik;\n                            distances2[index_j][index_i] = d_ik;\n                            next[index_i][index_j] = [];\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                            continue;\n                        } else if (d_ij == d_ik) {\n                            next[index_i][index_j] = next[index_i][index_j].concat(next[index_k][index_j]);\n                        }\n                    }\n                    c++;\n                    distances2[index_j][index_i] = distances[index_j][index_i];\n                    distances2[index_i][index_j] = distances[index_i][index_j];\n                }\n            }\n        }\n\n        var t = distances2;\n        distances2 = distances;\n        distances = t;\n\n    }\n\n    return {\n        'ordering': subset,\n        'distances': distances,\n        'next': next\n    };\n\n}\n\nfunction hivtrace_filter_to_node_in_cluster(node, obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges,\n        cluster_id = null;\n\n    // Retrieve nodes that are part of the cluster\n    var node_obj = nodes.filter(function(n) {\n        return node == n.id;\n    });\n\n    if (node_obj) {\n        cluster_id = node_obj[0].cluster;\n    } else {\n        console.log('could not find node');\n        return null;\n    }\n\n    // Filter out all edges and nodes that belong to the cluster\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster_id == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n    return filtered_obj;\n\n}\n\nfunction hivtrace_compute_betweenness_centrality_all_nodes_in_cluster(cluster, obj, cb) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n\n    var nodes_in_cluster = nodes.filter(function(n) {\n        return cluster == n.cluster;\n    });\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n    var edges_in_cluster = edges.filter(function(e) {\n        return node_ids.indexOf(e.sequences[0]) != -1\n    });\n\n    var filtered_obj = {};\n    filtered_obj[\"Nodes\"] = nodes_in_cluster;\n    filtered_obj[\"Edges\"] = edges_in_cluster;\n\n    // get length of cluster\n    if (nodes_in_cluster.length > 70) {\n        cb('cluster too large', null);\n        return;\n    }\n\n    // get paths\n    var paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    var node_ids = nodes_in_cluster.map(function(n) {\n        return n.id\n    });\n\n    var betweenness = {}\n    nodes_in_cluster.forEach(function(n) {\n        betweenness[n.id] = hivtrace_compute_betweenness_centrality(n.id, filtered_obj, paths);\n    });\n\n    cb(null, betweenness);\n    return;\n\n}\n\n// Returns dictionary of nodes' betweenness centrality\n// Utilizes the Floyd-Warshall Algorithm with reconstruction\nfunction hivtrace_compute_betweenness_centrality(node, obj, paths) {\n\n    if (!paths) {\n        var filtered_obj = hivtrace_filter_to_node_in_cluster(node, obj)\n        paths = hivtrace_compute_shortest_paths_with_reconstruction(filtered_obj);\n    }\n\n    // find index of id\n    var index = paths['ordering'].indexOf(node);\n\n    if (index == -1) {\n        return null;\n    }\n\n    var length = paths['distances'].length;\n\n    if (length != 2) {\n        scale = 1 / ((length - 1) * (length - 2));\n    } else {\n        scale = 1;\n    }\n\n\n    // If s->t goes through 1, add to sum\n    // Reconstruct each shortest path and check if node is in it\n    var paths_with_node = [];\n    for (i in _.range(length)) {\n        for (j in _.range(length)) {\n            paths_with_node.push(hivtrace_paths_with_node(index, paths['next'], i, j));\n        }\n    }\n\n    return d3.sum(paths_with_node) * scale;\n\n}\n\n\nfunction hivtrace_compute_node_degrees(obj) {\n\n    var nodes = obj.Nodes,\n        edges = obj.Edges;\n\n    for (var n in nodes) {\n        nodes[n].degree = 0;\n    }\n\n    for (var e in edges) {\n        nodes[edges[e].source].degree++;\n        nodes[edges[e].target].degree++;\n    }\n\n}\n\nfunction hivtrace_get_node_by_id(id, obj) {\n    return obj.Nodes.filter(function(n) {\n        return id == n.id\n    })[0] || undefined;\n}\n\nfunction hivtrace_compute_cluster_betweenness(obj, callback) {\n\n    var nodes = obj.Nodes;\n\n    function onlyUnique(value, index, self) {\n        return self.indexOf(value) === index;\n    }\n\n    // Get all unique clusters\n    var clusters = nodes.map(function(n) {\n        return n.cluster\n    });\n    var unique_clusters = clusters.filter(onlyUnique);\n\n    var cb_count = 0;\n\n    function cb(err, results) {\n\n        cb_count++;\n\n        for (node in results) {\n            hivtrace_get_node_by_id(node, obj)['betweenness'] = results[node];\n        }\n\n        if (cb_count >= unique_clusters.length) {\n            callback('done');\n        }\n\n    }\n\n    // Compute betweenness in parallel\n    unique_clusters.forEach(function(cluster_id) {\n        datamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster(cluster_id, obj, cb);\n    });\n\n    // once all settled callback\n\n}\n\n\nfunction hivtrace_is_contaminant(node) {\n    return node.attributes.indexOf('problematic') != -1;\n}\n\nfunction hivtrace_convert_to_csv(obj, callback) {\n    //Translate nodes to rows, and then use d3.format\n    hivtrace_compute_node_degrees(obj);\n\n    hivtrace_compute_cluster_betweenness(obj, function(err) {\n        var node_array = obj.Nodes.map(function(d) {\n            return [d.id, d.cluster, d.degree, d.betweenness, hivtrace_is_contaminant(d), d.attributes.join(';')]\n        });\n        node_array.unshift(['seqid', 'cluster', 'degree', 'betweenness', 'is_contaminant', 'attributes'])\n        node_csv = d3.csv.format(node_array);\n        callback(null, node_csv);\n    });\n}\n\nfunction hivtrace_export_csv_button(graph, tag) {\n\n    var data = hivtrace_convert_to_csv(graph, function(err, data) {\n        if (data != null) {\n            var pom = document.createElement('a');\n            pom.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent(data));\n            pom.setAttribute('download', 'export.csv');\n            pom.className = 'btn btn-default btn-sm';\n            pom.innerHTML = '<span class=\"glyphicon glyphicon-floppy-save\"></span> Export Results';\n            $(tag).append(pom);\n        }\n    });\n\n}\n\nfunction hiv_trace_export_table_to_text(parent_id, table_id, sep) {\n\n    var the_button = d3.select(parent_id).append(\"a\")\n        .attr(\"target\", \"_blank\")\n        .on(\"click\", function(data, element) {\n            var table_tag = d3.select(this).attr(\"data-table\");\n            var table_text = datamonkey.helpers.table_to_text(table_tag);\n            datamonkey.helpers.export_handler(table_text, table_tag.substring(1) + \".tsv\", \"text/tab-separated-values\");\n        })\n        .attr(\"data-table\", table_id);\n\n    the_button.append(\"i\").classed(\"fa fa-download fa-2x\", true);\n    return the_button;\n\n}\n\nhivtrace_compute_local_clustering_coefficients = _.once (function (obj) {\n\n  datamonkey.hivtrace.new_cluster_adjacency_list(obj);\n\n  var nodes = obj.Nodes;\n\n  nodes.forEach (function (n) {\n  \n    var a_node = n;\n    var neighborhood_size = a_node.neighbors.size();\n\n    if (neighborhood_size < 2) {\n        a_node.lcc = undefined;\n    } else {\n\n        if (neighborhood_size > 500) {\n            a_node.lcc = datamonkey.hivtrace.too_large;     \n        } else {\n            // count triangles\n            neighborhood = a_node.neighbors.values();\n            counter = 0;\n            for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n                for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                    if (nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\n                        counter ++;\n                    }\n                }\n            }\n            a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n        }\n    }\n\n  });\n\n});\n\nfunction hivtrace_render_settings(settings, explanations) {\n    // TODO:\n    //d3.json (explanations, function (error, expl) {\n    //    //console.log (settings);\n    //});\n}\n\nfunction hivtrace_format_value(value, formatter) {\n\n    if (typeof value === 'undefined') {\n        return \"Not computed\";\n    }\n    if (value === datamonkey.hivtrace.undefined) {\n        return \"Undefined\";\n    }\n    if (value === datamonkey.hivtrace.too_large) {\n        return \"Size limit\";\n    }\n\n    if (value === datamonkey.hivtrace.processing) {\n        return '<span class=\"fa fa-spin fa-spinner\"></span>';\n    }\n\n    return formatter ? formatter(value) : value;\n\n}\n\n\nif (typeof datamonkey == 'undefined') {\n    datamonkey = function() {};\n}\n\nif (typeof datamonkey.hivtrace == 'undefined') {\n    datamonkey.hivtrace = function() {};\n}\n\ndatamonkey.hivtrace.compute_node_degrees = hivtrace_compute_node_degrees;\ndatamonkey.hivtrace.export_csv_button = hivtrace_export_csv_button;\ndatamonkey.hivtrace.convert_to_csv = hivtrace_convert_to_csv;\ndatamonkey.hivtrace.betweenness_centrality = hivtrace_compute_betweenness_centrality;\ndatamonkey.hivtrace.betweenness_centrality_all_nodes_in_cluster = hivtrace_compute_betweenness_centrality_all_nodes_in_cluster;\ndatamonkey.hivtrace.cluster_adjacency_list = hivtrace_cluster_adjacency_list;\ndatamonkey.hivtrace.new_cluster_adjacency_list = hivtrace_new_cluster_adjacency_list;\ndatamonkey.hivtrace.analysis_settings = hivtrace_render_settings;\ndatamonkey.hivtrace.export_table_to_text = hiv_trace_export_table_to_text;\ndatamonkey.hivtrace.compute_local_clustering = hivtrace_compute_local_clustering_coefficients;\ndatamonkey.hivtrace.undefined = new Object();\ndatamonkey.hivtrace.too_large = new Object();\ndatamonkey.hivtrace.processing = new Object();\ndatamonkey.hivtrace.format_value = hivtrace_format_value;\n","function hivtrace_histogram(graph, histogram_tag, histogram_label) {  \n\n  var defaultFloatFormat = d3.format(\",.2f\");\n  var histogram_w = 300,\n  histogram_h = 300;\n\n  hivtrace_render_histogram(graph[\"Degrees\"][\"Distribution\"], \n                            graph[\"Degrees\"][\"fitted\"], \n                            histogram_w, \n                            histogram_h, \n                            histogram_tag);\n  var label = \"Network degree distribution is best described by the <strong>\" + graph[\"Degrees\"][\"Model\"] + \"</strong> model, with &rho; of \" + \n             defaultFloatFormat(graph[\"Degrees\"][\"rho\"]);\n             \n  if (graph[\"Degrees\"][\"rho CI\"] != undefined) {\n        label += \" (95% CI \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][0]) + \" - \" + defaultFloatFormat(graph[\"Degrees\"][\"rho CI\"][1]) + \")\";\n  }\n\n  d3.select (histogram_label).html(label);\n}\n\nfunction hivtrace_render_histogram(counts, fit, w, h, id) {\n\n    var margin = {top: 10, right: 30, bottom: 50, left: 30},\n                width = w - margin.left - margin.right,\n                height = h - margin.top - margin.bottom;\n    \n    var x = d3.scale.linear()\n            .domain([0, counts.length+1])\n            .range([0, width]);\n            \n    var y = d3.scale.log()\n            .domain ([1, d3.max (counts)])\n            .range  ([height,0]);\n            \n    var total = d3.sum(counts);\n\n    var xAxis = d3.svg.axis()\n        .scale(x)\n        .orient(\"bottom\");\n        \n    var histogram_svg = d3.select(id).selectAll(\"svg\");\n\n    if (histogram_svg != undefined) {\n        histogram_svg.remove();\n    }\n    \n    var data_to_plot = counts.map (function (d, i) {return {'x' : i+1, 'y' : d+1};});\n    data_to_plot.push ({'x' : counts.length+1, 'y' : 1});\n    data_to_plot.push ({'x' : 0, 'y' : 1});\n    data_to_plot.push ({'x' : 0, 'y' : counts[0]+1});\n   \n    histogram_svg = d3.select(id).insert(\"svg\",\".histogram-label\")\n    .attr(\"width\", width + margin.left + margin.right)\n    .attr(\"height\", height + margin.top + margin.bottom)\n    .append(\"g\")\n    .attr(\"transform\", \"translate(\" + margin.left + \",\" + margin.top + \")\")\n    .datum (data_to_plot);\n        \n    var histogram_line = d3.svg.line()\n                        .x(function(d) { return x(d.x); })\n                        .y(function(d) { return y(d.y); })\n                        .interpolate(\"step-before\");\n                        \n    histogram_svg.selectAll (\"path\").remove();\n    histogram_svg.append (\"path\")\n                 .attr (\"d\", function(d) { return histogram_line(d) + \"Z\"; })\n                 .attr (\"class\", \"histogram\");\n    \n    /*var bar = histogram_svg.selectAll(\".bar\")\n    .data(counts.map (function (d) { return d+1; }))\n    .enter().append(\"g\")\n    .attr(\"class\", \"bar\")\n    .attr(\"transform\", function(d,i) { return \"translate(\" + x(i+1) + \",\" + y(d) + \")\"; });\n      \n    bar.append(\"rect\")\n        .attr(\"x\", 1)\n        .attr(\"width\", function (d,i) {return x(i+2) - x(i+1);})\n        .attr(\"height\", function(d) { return height - y(d); })\n        .append (\"title\").text (function (d,i) { return \"\" + counts[i] + \" nodes with degree \" + (i+1);});*/\n        \n      \n\n      if (fit != undefined) {    \n          var fit_line = d3.svg.line()\n              .interpolate(\"linear\")\n              .x(function(d,i) { return x(i+1) + (x(i+1)-x(i))/2; })\n              .y(function(d) { return y(1+d*total); });\n          histogram_svg.append(\"path\").datum(fit)\n            .attr(\"class\", \"line\")\n            .attr(\"d\", function(d) { return fit_line(d); });\n      }\n    \n    var x_axis = histogram_svg.append(\"g\")\n        .attr(\"class\", \"x axis\")\n        .attr(\"transform\", \"translate(0,\" + height + \")\")\n        .call(xAxis);    \n        \n    x_axis.selectAll (\"text\").attr (\"transform\", \"rotate(45)\").attr(\"dx\",\"1em\").attr(\"dy\",\"0.5em\");\n}\n\ndatamonkey.hivtrace.histogram = hivtrace_histogram;\n","var _networkGraphAttrbuteID = \"user attributes\";\nvar _defaultFloatFormat = d3.format(\",.2r\");\n\n\n\nvar hivtrace_cluster_network_graph = function (json, network_container, network_status_string, network_warning_tag, button_bar_ui, attributes, filter_edges_toggle, clusters_table, nodes_table, parent_container) {\n\n  // [REQ] json                        :          the JSON object containing network nodes, edges, and meta-information\n  // [REQ] network_container           :          the CSS selector of the DOM element where the SVG containing the network will be placed (e.g. '#element')\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] network_warning_tag         :          the CSS selector of the DOM element where the any warning messages would go (e.g. '#element')\n  // [OPT] button_bar_ui               :          the ID of the control bar which can contain the following elements (prefix = button_bar_ui value)\n  //                                                - [prefix]_cluster_operations_container : a drop-down for operations on clusters\n  //                                                - [prefix]_attributes :  a drop-down for operations on attributes\n  //                                                - [prefix]_filter : a text box used to search the graph\n  // [OPT] network_status_string       :          the CSS selector of the DOM element where the text describing the current state of the network is shown (e.g. '#element')\n  // [OPT] attributes                  :          A JSON object with mapped node attributes\n\n  var self = new Object;\n\n    self.ww = d3.select(parent_container).property(\"clientWidth\");\n    self.nodes = [];\n    self.edges = [];\n    self.clusters = [];         \n    self.cluster_sizes = [];\n    self.colorizer = {'selected': function (d) {return d == 'selected' ? d3.rgb(51, 122, 183) : '#FFF';}}\n    self.filter_edges = true,\n    self.hide_hxb2 = false,\n    self.charge_correction = 1,\n    self.margin = {top: 20, right: 10, bottom: 30, left: 10},\n    self.width  = self.ww - self.margin.left - self.margin.right,\n    self.height = 500 - self.margin.top - self.margin.bottom,\n    self.cluster_table = d3.select (clusters_table),\n    self.node_table = d3.select (nodes_table),\n    self.needs_an_update = false,\n    self.json = json;\n\n  var cluster_mapping = {},\n      l_scale = 5000,   // link scale\n      graph_data = self.json,     // the raw JSON network object\n      max_points_to_render = 500,\n      warning_string     = \"\",\n      singletons         = 0,\n      open_cluster_queue = [],\n      currently_displayed_objects;\n\n  /*------------ D3 globals and SVG elements ---------------*/\n\n  var network_layout = d3.layout.force()\n    .on(\"tick\", tick)\n    .charge(function(d) { if (d.cluster_id) return self.charge_correction*(-50-20*Math.pow(d.children.length,0.7)); return self.charge_correction*(-20*Math.sqrt(d.degree)); })\n    .linkDistance(function(d) { return Math.max(d.length*l_scale,1); })\n    .linkStrength (function (d) { if (d.support != undefined) { return 2*(0.5-d.support);} return 1;})\n    .chargeDistance (500)\n    .friction (0.25);\n        \n  d3.select(network_container).selectAll (\".my_progress\").remove();\n\n  var network_svg = d3.select(network_container).append(\"svg:svg\")\n      .style (\"border\", \"solid black 1px\")\n      .attr(\"id\", \"network-svg\")\n      .attr(\"width\", self.width + self.margin.left + self.margin.right)\n      .attr(\"height\", self.height + self.margin.top + self.margin.bottom);\n\n      //.append(\"g\")\n      // .attr(\"transform\", \"translate(\" + self.margin.left + \",\" + self.margin.top + \")\");\n\n  network_svg.append(\"defs\").append(\"marker\")\n      .attr(\"id\", \"arrowhead\")\n      .attr(\"refX\", 9) /*must be smarter way to calculate shift*/\n      .attr(\"refY\", 2)\n      .attr(\"markerWidth\",  6)\n      .attr(\"markerHeight\", 4)\n      .attr(\"orient\", \"auto\")\n      .attr(\"stroke\", \"#666666\")\n      .attr(\"fill\", \"#AAAAAA\")\n      .append(\"path\")\n          .attr(\"d\", \"M 0,0 V 4 L6,2 Z\"); //this is actual shape for arrowhead\n   \n  change_window_size();                                   \n   \n  /*------------ Network layout code ---------------*/\n  var handle_cluster_click = function (cluster, release) {\n\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select (\"#\" + id);\n    \n    if (menu_object.empty()) {\n      menu_object = container.append (\"ul\")\n        .attr (\"id\", id)\n        .attr (\"class\",\"dropdown-menu\")\n        .attr (\"role\", \"menu\");\n    } \n\n    menu_object.selectAll (\"li\").remove();\n\n    var already_fixed = cluster && cluster.fixed == 1;\n    \n\n    if (cluster) {\n      menu_object.append(\"li\").append (\"a\")\n                   .attr(\"tabindex\", \"-1\")\n                   .text(\"Expand cluster\")\n                   .on (\"click\", function (d) {\n                      cluster.fixed = 0;\n                      expand_cluster_handler(cluster, true);\n                      menu_object.style (\"display\", \"none\"); \n                      });\n\n      menu_object.append(\"li\").append (\"a\")\n                   .attr (\"tabindex\", \"-1\")\n                   .text (\"Center on screen\")\n                   .on (\"click\", function (d) {\n                      cluster.fixed = 0;\n                      center_cluster_handler(cluster);\n                      menu_object.style (\"display\", \"none\"); \n                      });\n                      \n     menu_object.append(\"li\").append (\"a\")\n               .attr (\"tabindex\", \"-1\")\n               .text (function (d) {if (cluster.fixed) return \"Release fix\"; return \"Fix in place\";})\n               .on (\"click\", function (d) {\n                  cluster.fixed = !cluster.fixed;\n                  menu_object.style (\"display\", \"none\"); \n                  });\n\n     cluster.fixed = 1;\n\n     menu_object.style (\"position\", \"absolute\")\n        .style(\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style(\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style(\"display\", \"block\");\n\n    } else {\n      if (release) {\n        release.fixed = 0;\n      }\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function (d) {handle_cluster_click(null, already_fixed ? null : cluster);}, true);\n\n  };\n\n  var handle_node_click = function (node) {\n    var container = d3.select(network_container);\n    var id = \"d3_context_menu_id\";\n    var menu_object = container.select (\"#\" + id);\n    \n    if (menu_object.empty()) {\n      menu_object = container.append (\"ul\")\n        .attr (\"id\", id)\n        .attr (\"class\",\"dropdown-menu\")\n        .attr (\"role\", \"menu\");\n    } \n\n    menu_object.selectAll (\"li\").remove();\n\n    if (node) {\n      node.fixed = 1;\n      menu_object.append(\"li\").append (\"a\")\n                   .attr(\"tabindex\", \"-1\")\n                   .text(\"Collapse cluster\")\n                   .on (\"click\", function (d) {\n                      node.fixed = 0;\n                      collapse_cluster_handler(node, true)\n                      menu_object.style (\"display\", \"none\"); \n                      });\n\n      menu_object.style (\"position\", \"absolute\")\n        .style (\"left\", \"\" + d3.event.offsetX + \"px\")\n        .style (\"top\", \"\" + d3.event.offsetY + \"px\")\n        .style (\"display\", \"block\");\n\n    } else {\n      menu_object.style(\"display\", \"none\");\n    }\n\n    container.on(\"click\", function (d) {handle_node_click(null);}, true);\n\n  };\n\n  function get_initial_xy (nodes, cluster_count, exclude ) { \n      var d_clusters = {'id': 'root', 'children': []};\n      for (var k = 0; k < cluster_count; k+=1) {\n       if (exclude != undefined && exclude[k+1] != undefined) {continue;}\n          d_clusters.children.push ({'cluster_id' : k+1, 'children': nodes.filter (function (v) {return v.cluster == k+1;})});\n      }   \n      \n      var treemap = d3.layout.treemap()\n      .size([self.width, self.height])\n      .sticky(true)\n      .children (function (d)  {return d.children;})\n      .value(function(d) { return 1;});\n      \n      return treemap.nodes (d_clusters);\n  }\n\n  function prepare_data_to_graph () {\n\n      var graphMe = {};\n      graphMe.all = [];\n      graphMe.edges = [];\n      graphMe.nodes = [];\n      graphMe.clusters = [];\n\n      expandedClusters = [];\n      drawnNodes = [];\n      \n      \n      self.clusters.forEach (function (x) {\n          // Check if hxb2_linked is in a child\n          var hxb2_exists = x.children.some(function(c) {return c.hxb2_linked}) && self.hide_hxb2;\n          if(!hxb2_exists) {\n            if (x.collapsed) {\n                graphMe.clusters.push (x);\n                graphMe.all.push(x);\n            } else {\n                expandedClusters[x.cluster_id] = true;\n            }\n          }\n      });\n      \n      self.nodes.forEach (function (x, i) {\n          if (expandedClusters[x.cluster]) {\n              drawnNodes[i] = graphMe.nodes.length +  graphMe.clusters.length;\n              graphMe.nodes.push(x); \n              graphMe.all.push(x); \n          } \n      \n      });\n      \n      self.edges.forEach (function (x) {\n\n          if(!(x.removed && self.filter_edges)) {\n            if (drawnNodes[x.source] != undefined && drawnNodes[x.target] != undefined) {\n\n                var y = {};\n                for (var prop in x) {\n                    y[prop] = x[prop];\n                }\n\n                y.source = drawnNodes[x.source];\n                y.target = drawnNodes[x.target];\n                graphMe.edges.push(y);\n            }\n          }\n      });\n\n      return graphMe;\n\n  }\n\n  function default_layout (clusters, nodes, exclude_cluster_ids) {\n        init_layout = get_initial_xy (nodes, self.cluster_sizes.length, exclude_cluster_ids);\n        clusters = init_layout.filter (function (v,i,obj) { return  !(typeof v.cluster_id === \"undefined\");});\n        nodes = nodes.map (function (v) {v.x += v.dx/2; v.y += v.dy/2; return v;});\n        clusters.forEach (collapse_cluster); \n        return [clusters, nodes];\n    }\n    \n function change_spacing (delta) {\n    self.charge_correction = self.charge_correction * delta;\n    network_layout.start ();\n }\n\n function change_window_size (delta, trigger) {\n \n    if (delta) {\n        self.width  += delta;\n        self.height += delta;\n    \n        self.width  = Math.min (Math.max (self.width, 200), 4000); \n        self.height = Math.min (Math.max (self.height, 200), 4000);\n    } \n    \n    network_layout.size ([self.width, self.height - 160]);\n    network_svg.attr (\"width\", self.width).attr (\"height\", self.height);\n    \n    if (trigger) {\n        network_layout.start ();       \n    }\n    \n }\n \n self.compute_adjacency_list = _.once(function () {    \n\n    self.nodes.forEach (function (n) {\n        n.neighbors = d3.set();\n    });\n    \n    self.edges.forEach (function (e) {\n        self.nodes[e.source].neighbors.add(e.target);\n        self.nodes[e.target].neighbors.add(e.source);\n    });\n\n });\n \n self.compute_local_clustering_coefficients = _.once (function () {\n\n    self.compute_adjacency_list();\n    \n    self.nodes.forEach (function (n) {\n        _.defer (function (a_node) {\n            neighborhood_size = a_node.neighbors.size ();\n            if (neighborhood_size < 2) {\n                a_node.lcc = datamonkey.hivtrace.undefined;     \n            } else {\n                if (neighborhood_size > 500) {\n                    a_node.lcc = datamonkey.hivtrace.too_large;     \n                } else {\n                    // count triangles\n                    neighborhood = a_node.neighbors.values();\n                    counter = 0;\n                    for (n1 = 0; n1 < neighborhood_size; n1 += 1) {\n                        for (n2 = n1 + 1; n2 < neighborhood_size; n2 += 1) {\n                            if (self.nodes [neighborhood[n1]].neighbors.has (neighborhood[n2])) {\n                                counter ++;\n                            }\n                        }\n                    }\n                    \n                    a_node.lcc = 2 * counter / neighborhood_size / (neighborhood_size - 1);\n                }\n            }\n            \n        }, n);\n    });\n\n });\n\n  self.get_node_by_id = function(id) {\n    return self.nodes.filter(function(n) {\n        return n.id == id;\n    })[0];\n\n\n  }\n\n self.compute_local_clustering_coefficients_worker = _.once (function () {\n\n    var worker = new Worker('workers/lcc.js');\n\n    worker.onmessage = function(event) {\n\n      var nodes = event.data.Nodes;\n\n      nodes.forEach(function(n) { \n        node_to_update = self.get_node_by_id(n.id);\n        node_to_update.lcc = n.lcc ? n.lcc : datamonkey.hivtrace.undefined;\n      });\n\n    };\n\n    var worker_obj = {}\n    worker_obj[\"Nodes\"] = self.nodes;\n    worker_obj[\"Edges\"] = self.edges;\n    worker.postMessage(worker_obj);\n\n });\n\n\n  \n  estimate_cubic_compute_cost = _.memoize(function (c) {\n    self.compute_adjacency_list();  \n    return _.reduce (_.first(_.pluck (c.children, \"degree\").sort (d3.descending),3),function (memo, value) {return memo*value;},1); \n  }, function (c) {return c.cluster_id;});\n  \n  self.compute_global_clustering_coefficients = _.once (function () {\n    self.compute_adjacency_list();\n \n    self.clusters.forEach (function (c) {\n         _.defer (function (a_cluster) {\n                cluster_size = a_cluster.children.length;\n                if (cluster_size < 3) {\n                    a_cluster.cc = datamonkey.hivtrace.undefined;     \n                } else {\n                    if (estimate_cubic_compute_cost (a_cluster, true) >= 5000000) {\n                        a_cluster.cc = datamonkey.hivtrace.too_large;     \n                    } else {\n                        // pull out all the nodes that have this cluster id\n                        member_nodes = [];\n                        \n                        var triads = 0;\n                        var triangles = 0; \n                        \n                        self.nodes.forEach (function (n,i) {if (n.cluster == a_cluster.cluster_id) {member_nodes.push (i);}});\n                        member_nodes.forEach (function (node) {\n                            my_neighbors = self.nodes[node].neighbors.values().map (function (d) {return +d;}).sort (d3.ascending);\n                            for (n1 = 0; n1 < my_neighbors.length; n1 += 1) {\n                                for (n2 = n1 + 1; n2 < my_neighbors.length; n2 += 1) {\n                                    triads += 1;\n                                    if (self.nodes[my_neighbors[n1]].neighbors.has (my_neighbors[n2])) {\n                                        triangles += 1;\n                                    }\n                                }\n                            }\n                        });\n                        \n                        a_cluster.cc = triangles/triads;\n                    }\n                }\n        \n            }, c);    \n        });\n });\n\n self.mark_nodes_as_processing = function (property) {\n    self.nodes.forEach (function (n) { n[property] = datamonkey.hivtrace.processing }); \n  }\n \n self.compute_graph_stats = function () {\n\n    d3.select (this).classed (\"disabled\", true).select(\"i\").classed ({\"fa-calculator\": false, \"fa-cog\": true, \"fa-spin\": true});\n    self.mark_nodes_as_processing('lcc');\n    self.compute_local_clustering_coefficients_worker();\n    self.compute_global_clustering_coefficients();\n    d3.select (this).remove();\n\n };\n\n\n  /*------------ Constructor ---------------*/\n  function initial_json_load() {\n    var connected_links = [];\n    var total = 0;\n    var exclude_cluster_ids = {};\n    self.has_hxb2_links = false;\n    self.cluster_sizes = [];\n\n    graph_data.Nodes.forEach (function (d) { \n          if (typeof self.cluster_sizes[d.cluster-1]  === \"undefined\") {\n            self.cluster_sizes[d.cluster-1] = 1;\n          } else {\n            self.cluster_sizes[d.cluster-1] ++;\n          }\n          if (\"is_lanl\" in d) {\n            d.is_lanl = d.is_lanl == \"true\";\n          }\n          \n          \n          if (d.attributes.indexOf (\"problematic\") >= 0) {\n            self.has_hxb2_links = d.hxb2_linked = true;\n          }\n      \n    });\n\n     /* add buttons and handlers */\n     /* clusters first */\n     \n     if (button_bar_ui) {\n     \n         var cluster_ui_container = d3.select (\"#\" + button_bar_ui + \"_cluster_operations_container\");\n         \n         [\n            [\"Expand All\",          function () {return self.expand_some_clusters()},   true, 'hivtrace-expand-all'],\n            [\"Collapse All\",        function () {return self.collapse_some_clusters()}, true, 'hivtrace-collapse-all'],\n            [\"Expand Filtered\",     function () {return self.expand_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))},   true, 'hivtrace-expand-filtered'],\n            [\"Collapse Filtered\",   function () {return self.collapse_some_clusters(self.select_some_clusters (function (n) {return n.match_filter;}))}, true, 'hivtrace-collapse-filtered'],\n            [\"Hide problematic clusters\", function (item) {\n                                            d3.select (item).text (self.hide_hxb2 ? \"Hide problematic clusters\" :  \"Show problematic clusters\");\n                                            self.toggle_hxb2 ();\n                                          }, self.has_hxb2_links, 'hivtrace-hide-problematic-clusters'],\n                                          \n            [\"Show removed edges\",   function (item) {\n                                        self.filter_edges = !self.filter_edges; \n                                        d3.select (item).text (self.filter_edges ? \"Show removed edges\" :  \"Hide removed edges\");\n                                        self.update (false); \n                                     }\n                                    , function () {return _.some (self.edges, function (d) {return d.removed;});}, 'hivtrace-show-removed-edges']\n            \n         ].forEach (function (item,index) {\n            var handler_callback = item[1];\n            if (item[2]) {\n                this.append (\"li\").append (\"a\")\n                                  .text (item[0])\n                                  .attr (\"href\", \"#\")\n                                  .attr (\"id\", item[3])\n                                  .on (\"click\", function(e) {\n                                    handler_callback(this);\n                                    d3.event.preventDefault();\n                                  });\n            }\n         },cluster_ui_container);\n         \n         \n         var button_group  = d3.select (\"#\" + button_bar_ui + \"_button_group\");\n         \n         if (! button_group.empty()) {\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Expand spacing\").on (\"click\", function (d) {change_spacing (5/4);}).append (\"i\").classed (\"fa fa-arrows\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Compress spacing\").on (\"click\", function (d) {change_spacing (4/5);}).append (\"i\").classed (\"fa fa-arrows-alt\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Enlarge window\").on (\"click\", function (d) {change_window_size (20, true);}).append (\"i\").classed (\"fa fa-expand\", true);\n            button_group.append (\"button\").classed (\"btn btn-default btn-sm\", true).attr (\"title\", \"Shrink window\").on (\"click\", function (d) {change_window_size (-20, true);}).append (\"i\").classed (\"fa fa-compress\", true);\n\n            button_group.append (\"button\")\n              .classed(\"btn btn-default btn-sm\", true)\n              .attr(\"title\", \"Compute graph statistics\")\n              .attr(\"id\", \"hivtrace-compute-graph-statistics\")\n              .on(\"click\", function (d) {_.bind(self.compute_graph_stats,this)();})\n              .append(\"i\")\n              .classed(\"fa fa-calculator\", true);\n\n            button_group.append (\"button\")\n              .classed(\"btn btn-default btn-sm\", true)\n              .attr(\"title\", \"Save Image\")\n              .attr(\"id\", \"hivtrace-export-image\")\n              .on(\"click\", function(d) { datamonkey.save_image(\"png\", \"#network-svg\");})\n              .append (\"i\").classed (\"fa fa-image\", true);\n         }\n         \n         $(\"#\" + button_bar_ui + \"_filter\").on (\"input propertychange\", _.throttle (function (e) {  \n               var filter_value = $(this).val();\n               self.filter (filter_value.split (\" \").filter (function (d) {return d.length > 0;}).map (function (d) { return new RegExp (d,\"i\")}));\n            }, 250));\n        \n    }\n     \n    \n     if (attributes && \"hivtrace\" in attributes) {\n        attributes = attributes[\"hivtrace\"];\n     }\n     \n     if (attributes && \"attribute_map\" in attributes) {\n         /*  \n            map attributes into nodes and into the graph object itself using \n            _networkGraphAttrbuteID as the key  \n         */\n     \n         var attribute_map = attributes[\"attribute_map\"];\n     \n         if (\"map\" in attribute_map && attribute_map[\"map\"].length > 0) {\n             graph_data [_networkGraphAttrbuteID] = attribute_map[\"map\"].map (function (a,i) { return {'label': a, 'type' : null, 'values': {}, 'index' : i, 'range' : 0};});   \n             \n             graph_data.Nodes.forEach (function (n) { \n                n[_networkGraphAttrbuteID] = n.id.split (attribute_map[\"delimiter\"]);\n                n[_networkGraphAttrbuteID].forEach (function (v,i) {\n                    if (i < graph_data [_networkGraphAttrbuteID].length) {\n                        if (! (v in graph_data [_networkGraphAttrbuteID][i][\"values\"])) {\n                            graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = graph_data [_networkGraphAttrbuteID][i][\"range\"];\n                            graph_data [_networkGraphAttrbuteID][i][\"range\"] += 1;\n                        }\n                    }\n                    //graph_data [_networkGraphAttrbuteID][i][\"values\"][v] = 1 + (graph_data [_networkGraphAttrbuteID][i][\"values\"][v] ? graph_data [_networkGraphAttrbuteID][i][\"values\"][v] : 0);\n                });\n            });\n           \n            graph_data [_networkGraphAttrbuteID].forEach (function (d) {\n                if (d['range'] < graph_data.Nodes.length && d['range'] > 1 &&d['range' ] <= 20) {\n                    d['type'] = 'category';\n                }\n            });\n            \n            \n            // populate the UI elements\n            if (button_bar_ui) {\n                var valid_cats = graph_data [_networkGraphAttrbuteID].filter (function (d) { return d['type'] == 'category'; });\n                //valid_cats.splice (0,0, {'label' : 'None', 'index' : -1});\n                               \n                [d3.select (\"#\" + button_bar_ui + \"_attributes\"),d3.select (\"#\" + button_bar_ui + \"_attributes_cat\")].forEach (function (m) {\n                \n                    m.selectAll (\"li\").remove();\n                \n                    var cat_menu = m.selectAll (\"li\")\n                                    .data([[['None',-1]],[['Categorical', -2]]].concat(valid_cats.map (function (d) {return [[d['label'],d['index']]];})));        \n                                                                     \n                    cat_menu.enter ().append (\"li\").classed (\"disabled\", function (d) {return d[0][1] < -1;});\n                    cat_menu.selectAll (\"a\").data (function (d) {return d;})\n                                            .enter ()\n                                            .append (\"a\")\n                                            .text (function (d,i,j) {return d[0];})\n                                            .attr (\"style\", function (d,i,j) {if (d[1] < -1) return 'font-style: italic'; if (j == 0) { return ' font-weight: bold;'}; return null; })\n                                            .attr ('href', '#')\n                                            .on (\"click\", function (d) { handle_attribute_categorical (d[1]); });\n                });\n            }\n        }\n    }\n    \n    if (self.cluster_sizes.length > max_points_to_render) {\n      var sorted_array = self.cluster_sizes.map (function (d,i) { \n          return [d,i+1]; \n        }).sort (function (a,b) {\n          return a[0] - b[0];\n        });\n\n      for (var k = 0; k < sorted_array.length - max_points_to_render; k++) {\n          exclude_cluster_ids[sorted_array[k][1]] = 1;\n      }\n      warning_string = \"Excluded \" + (sorted_array.length - max_points_to_render) + \" clusters (maximum size \" +  sorted_array[k-1][0] + \" nodes) because only \" + max_points_to_render + \" points can be shown at once.\";\n    }\n    \n    // Initialize class attributes\n    singletons = graph_data.Nodes.filter (function (v,i) { return v.cluster === null; }).length; self.nodes = graph_data.Nodes.filter (function (v,i) { if (v.cluster && typeof exclude_cluster_ids[v.cluster]  === \"undefined\"  ) {connected_links[i] = total++; return true;} return false;  });\n    self.edges = graph_data.Edges.filter (function (v,i) { return connected_links[v.source] != undefined && connected_links[v.target] != undefined});\n    self.edges = self.edges.map (function (v,i) {v.source = connected_links[v.source]; v.target = connected_links[v.target]; v.id = i; return v;});\n\n    compute_node_degrees(self.nodes, self.edges);\n\n    var r = default_layout(self.clusters, self.nodes, exclude_cluster_ids);\n    self.clusters = r[0];\n    self.nodes = r[1];\n    self.clusters.forEach (function (d,i) {\n            cluster_mapping[d.cluster_id] = i;\n            d.hxb2_linked = d.children.some(function(c) {return c.hxb2_linked});\n            var degrees = d.children.map (function (c) {return c.degree;});\n            degrees.sort (d3.ascending);\n            d.degrees = datamonkey_describe_vector (degrees);\n            });\n     \n     \n    self.update();\n \n  }  \n  \n  function sort_table_toggle_icon (element, value) {\n    if (value) {\n        $(element).data (\"sorted\", value);\n        d3.select (element).selectAll (\"i\").classed (\"fa-sort-amount-desc\", value == \"desc\").classed (\"fa-sort-amount-asc\", value == \"asc\").classed (\"fa-sort\", value == \"unsorted\");\n    } else {\n        var sorted_state = $(element).data (\"sorted\");\n        sort_table_toggle_icon (element, sorted_state == \"asc\" ? \"desc\" : \"asc\");\n        return sorted_state == \"asc\" ? d3.descending: d3.ascending;\n    }\n  }\n  \n  function sort_table_by_column (element, datum) {\n    d3.event.preventDefault();\n    var table_element = $(element).closest (\"table\");\n    if (table_element.length) {\n        var sort_on             = parseInt($(element).data (\"column-id\"));\n        var sort_key            = $(element).data (\"sort-on\");\n        var sorted_state        = ($(element).data (\"sorted\"));\n        var sorted_function     = sort_table_toggle_icon (element);\n        \n        sort_accessor = sort_key ? function (x) {var val = x[sort_key]; if (typeof (val) === \"function\") return val (); return val;} : function (x) {return x;};\n        \n        d3.select (table_element[0]).select (\"tbody\").selectAll (\"tr\").sort (function (a,b) { return sorted_function (sort_accessor(a[sort_on]), sort_accessor(b[sort_on]));});\n        \n        // select all other elements from thead and toggle their icons\n        \n        $(table_element).find (\"thead [data-column-id]\")\n                        .filter (function () {return parseInt ($(this).data (\"column-id\")) != sort_on;})\n                        .each (function () { sort_table_toggle_icon (this, \"unsorted\");});\n    }\n  }\n  \n  function format_a_cell (data, index, item) {\n  \n     var this_sel  = d3.select (item);\n\n     current_value = typeof (data.value) === \"function\" ? data.value() : data.value;\n\n     if (\"callback\" in data) {\n        data.callback (item, current_value);\n     } else {  \n         var repr = \"format\" in data ?  data.format (current_value) : current_value;\n         if (\"html\" in data) this_sel.html (repr); else this_sel.text(repr);\n         if (\"sort\" in data) {\n            var clicker = this_sel.append (\"a\").property (\"href\", \"#\").on (\"click\", function (d) {sort_table_by_column (this, d);}).attr (\"data-sorted\", \"unsorted\").attr (\"data-column-id\", index).attr (\"data-sort-on\", data.sort);\n            clicker.append (\"i\").classed (\"fa fa-sort\", true).style (\"margin-left\", \"0.2em\");\n          }\n     }\n     if (\"help\" in data) {\n        this_sel.attr (\"title\", data.help);\n     }\n\n  }\n  \n  function add_a_sortable_table (container, headers, content) {\n\n        var thead = container.selectAll (\"thead\");\n        if (thead.empty()) {\n            thead = container.append (\"thead\");                    \n            thead.selectAll (\"tr\").data (headers).enter().append (\"tr\").selectAll (\"th\").data (function (d) {return d;}).enter().append (\"th\").\n                                  call (function (selection) { return selection.each (function (d, i) {\n                                        format_a_cell (d, i, this);\n                                    })\n                                  });\n        }  \n        \n        var tbody = container.selectAll (\"tbody\");\n        if (tbody.empty()) {\n            tbody = container.append (\"tbody\");\n            tbody.selectAll (\"tr\").data (content).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").call (function (selection) { return selection.each (function (d, i) {\n                                        handle_cluster_click \n                                        format_a_cell (d, i, this);\n                                    })\n                                  });\n        }\n        \n       \n  }\n  \n  \n  function _cluster_table_draw_buttons (element, payload) {\n    var this_cell = d3.select (element);\n    var labels = [[payload[0] ? \"expand\" : \"collapse\",0]];\n    if (payload[1]) {\n        labels.push ([\"problematic\",1]);\n    }\n    var buttons = this_cell.selectAll (\"button\").data (labels);\n    buttons.enter().append (\"button\");\n    buttons.exit().remove();\n    buttons.classed (\"btn btn-primary btn-xs\", true).text (function (d) {return d[0];})\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\n                                                 .on (\"click\", function (d) {\n                                                    if (d[1] == 0) {\n                                                        if (payload[0]) { \n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1], true);\n                                                        } else {\n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1]);\n                                                        }\n                                                        format_a_cell (d3.select (element).datum(), null, element);\n                                                    }\n                                                 });\n    \n  };\n  \n function _node_table_draw_buttons (element, payload) {\n    var this_cell = d3.select (element);\n    var labels = [[payload[0] ? \"hide\" : \"show\",0]];\n\n    var buttons = this_cell.selectAll (\"button\").data (labels);\n    buttons.enter().append (\"button\");\n    buttons.exit().remove();\n    buttons.classed (\"btn btn-primary btn-xs btn-node-property\", true).text (function (d) {return d[0];})\n                                                 .attr (\"disabled\", function (d) {return d[1] ? \"disabled\" : null})\n                                                 .on (\"click\", function (d) {\n                                                    if (d[1] == 0) {\n                                                        if (payload[0]) { \n                                                            collapse_cluster (self.clusters [payload[payload.length-1] - 1], true);\n                                                        } else {\n                                                            expand_cluster (self.clusters [payload[payload.length-1] - 1]);\n                                                        }\n                                                        format_a_cell (d3.select (element).datum(), null, element);\n                                                    }\n                                                 });\n    \n  };\n  \n  self.update_volatile_elements = function (container) {\n    container.selectAll (\"td\").filter (function (d,i) {\n        return (\"volatile\" in d);\n    }).each (function (d,i) {\n        format_a_cell (d, i, this);\n    });\n  };\n  \n  function draw_node_table () {\n\n    if (self.node_table) { \n        add_a_sortable_table (self.node_table,\n                                // headers\n                              [[{value:\"ID\", sort : \"value\", help: \"Node ID\"}, \n                                 {value: \"Visibility\", sort: \"value\"}, \n                                 {value: \"Degree\", sort: \"value\", help: \"Node degree\"}, \n                                 {value: \"Cluster\", sort: \"value\", help: \"Which cluster does the node belong to\"}, \n                                 {value: \"LCC\", sort: \"value\", help: \"Local clustering coefficient\"}\n                               ]], \n                                 // rows \n                               self.nodes.map (function (n, i) {\n                                console.log(datamonkey.hivtrace.format_value(n.lcc,_defaultFloatFormat));\n                                return [{\"value\": n.id, help: \"Node ID\"}, \n                                        {       \"value\": function () {return [!self.clusters [n.cluster-1].collapsed, n.cluster]}, \n                                                \"callback\": _node_table_draw_buttons,\n                                                \"volatile\" : true\n                                        }, \n                                        {\"value\" : n.degree, help: \"Node degree\"},\n                                        {\"value\" : n.cluster, help: \"Which cluster does the node belong to\"}, \n                                        {\"value\": function () {return datamonkey.hivtrace.format_value(n.lcc,_defaultFloatFormat);},\n                                         \"volatile\" : true, \"html\": true, help: \"Local clustering coefficient\"}];\n        \n                                }));\n    }\n  }\n  \n  function draw_cluster_table () {\n    if (self.cluster_table) {\n        add_a_sortable_table (self.cluster_table,\n                                // headers\n                              [[{value:\"ID\", sort : \"value\", help: \"Unique cluster ID\"}, \n                                 {value: \"Visibility\", sort: \"value\"}, \n                                 {value: \"Size\", sort: \"value\", help: \"Number of nodes in the cluster\"}, \n                                 {value: \"Degrees<br>Mean [Median, IQR]\", html : true}, \n                                 {value: \"CC\", sort: \"value\", help: \"Global clustering coefficient\"},\n                                 {value: \"MPL\", sort: \"value\", help: \"Mean Path Length\"}\n                               ]],\n                                self.clusters.map (function (d, i) {\n                                 // rows \n                                return [{value: d.cluster_id}, \n                                        {       value: function () {return [d.collapsed, d.hxb2_linked, d.cluster_id]}, \n                                                callback: _cluster_table_draw_buttons,\n                                                volatile : true\n                                        }, \n                                        {value :d.children.length},\n                                        {value : d.degrees, format: function (d) {return _defaultFloatFormat(d['mean']) + \" [\" + _defaultFloatFormat(d['median']) + \", \" + _defaultFloatFormat(d['Q1']) + \" - \" + _defaultFloatFormat(d['Q3']) +\"]\"}}, \n                                        {\n                                            value: function () {return hivtrace_format_value(d.cc,_defaultFloatFormat);},\n                                            volatile : true, \n                                            help: \"Global clustering coefficient\"\n                                        },\n                                        {\n                                            value: function () {return hivtrace_format_value(d.mpl,_defaultFloatFormat);},\n                                            volatile : true, \n                                            help: \"Mean path length\"\n                                        }\n                                        ];\n        \n                                })\n                                );\n        }     \n  }\n\n  /*------------ Update layout code ---------------*/\n  function update_network_string (draw_me) {\n      if (network_status_string) {\n          var clusters_shown = self.clusters.length-draw_me.clusters.length,\n              clusters_removed = self.cluster_sizes.length - self.clusters.length,\n              nodes_removed = graph_data.Nodes.length - singletons - self.nodes.length;\n          \n          var s = \"Displaying a network on <strong>\" + self.nodes.length + \"</strong> nodes, <strong>\" + self.clusters.length + \"</strong> clusters\"\n                  + (clusters_removed > 0 ? \" (an additional \" + clusters_removed + \" clusters and \" + nodes_removed + \" nodes have been removed due to network size constraints)\" : \"\") + \". <strong>\" \n                  + clusters_shown +\"</strong> clusters are expanded. Of <strong>\" + self.edges.length + \"</strong> edges, <strong>\" + draw_me.edges.length + \"</strong>, and of  <strong>\" + self.nodes.length  + \" </strong> nodes,  <strong>\" + draw_me.nodes.length + \" </strong> are displayed. \";\n          if (singletons > 0) {\n              s += \"<strong>\" +singletons + \"</strong> singleton nodes are not shown. \";\n          }\n          d3.select (network_status_string).html(s);\n    }\n  }\n\n  \n  function draw_a_node (container, node) {\n    container = d3.select(container);\n    container.attr(\"d\", d3.svg.symbol().size( node_size )\n        .type( function(d) { return (d.hxb2_linked && !d.is_lanl) ? \"cross\" : (d.is_lanl ? \"triangle-down\" : \"circle\") }))\n        .attr('class', 'node')\n        .attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\n        .style('fill', function(d) { return node_color(d); })\n        .on ('click', handle_node_click)\n        .on ('mouseover', node_pop_on)\n        .on ('mouseout', node_pop_off)\n        .call(network_layout.drag().on('dragstart', node_pop_off));\n  }\n    \n\n  function draw_a_cluster (container, the_cluster) {\n       \n     container_group = d3.select(container);\n     \n     \n     var draw_from   = the_cluster[\"binned_attributes\"] ? the_cluster[\"binned_attributes\"].map (function (d) {return d.concat ([0]);}) : [[null, 1, 0]];\n         \n     if (the_cluster.match_filter) {\n        draw_from = draw_from.concat ([[\"selected\",the_cluster.match_filter,1],[\"not selected\",the_cluster.children.length - the_cluster.match_filter,1]]);\n     }\n\n     var sums  = [d3.sum(draw_from.filter (function (d) {return d[2] == 0}),function (d) {return d[1];}),\n                  d3.sum(draw_from.filter (function (d) {return d[2] != 0}),function (d) {return d[1];})];\n                 \n     var running_totals = [0,0];\n\n     draw_from = draw_from.map (function (d) {  index = d[2];\n                                                var v = {'container' : container, \n                                                        'cluster': the_cluster, \n                                                        'startAngle' : running_totals[index]/sums[index]*2*Math.PI, \n                                                        'endAngle': (running_totals[index]+d[1])/sums[index]*2*Math.PI, \n                                                        'name': d[0],\n                                                        'rim' : index > 0}; \n                                                 running_totals[index] += d[1]; \n                                                 return v;\n                                                 \n                                             });\n     \n     \n     var arc_radius = cluster_box_size(the_cluster)*0.5;\n     var paths = container_group.selectAll (\"path\").data (draw_from);\n     paths.enter ().append (\"path\");\n     paths.exit  ().remove();\n     \n     paths.classed (\"cluster\", true)\n          .classed (\"hiv-trace-problematic\", function (d) {return the_cluster.hxb2_linked && !d.rim;})\n          .classed (\"hiv-trace-selected\", function (d) {return d.rim;})\n          .attr (\"d\", function (d) {\n                return (d.rim \n                        ? d3.svg.arc().innerRadius(arc_radius+2).outerRadius(arc_radius+5)\n                        : d3.svg.arc().innerRadius(0).outerRadius(arc_radius))(d);\n                })\n          .style (\"fill\", function (d,i) {return d.rim ? self.colorizer ['selected'] (d.name) : cluster_color (the_cluster, d.name);})\n          ;\n    \n     \n     \n  }\n  \n  function handle_attribute_categorical (cat_id) {\n  \n    var set_attr = \"None\";\n\n    [\"#\" + button_bar_ui + \"_attributes\",\"#\" + button_bar_ui + \"_attributes_cat\"].forEach (function (m) {\n        d3.select (m).selectAll (\"li\")\n                                                       .selectAll (\"a\")\n                                                       .attr (\"style\", function (d,i) {if (d[1] == cat_id) { set_attr = d[0]; return ' font-weight: bold;'}; return null; });\n      \n        d3.select (m + \"_label\").html (set_attr + ' <span class=\"caret\"></span>');\n    });\n                                                   \n\n\n     self.clusters.forEach (function (the_cluster) {the_cluster['binned_attributes'] = stratify(attribute_cluster_distribution (the_cluster, cat_id));});\n    \n     if (cat_id >= 0) {\n        self.colorizer['category']    = graph_data [_networkGraphAttrbuteID][cat_id]['range'] <= 10 ? d3.scale.category10() : d3.scale.category20c();\n        self.colorizer['category_id'] = cat_id;  \n        self.colorizer['category_map'] = graph_data [_networkGraphAttrbuteID][cat_id]['values'];\n        self.colorizer['category_map'][null] =  graph_data [_networkGraphAttrbuteID][cat_id]['range'];\n        self.colorizer['category_pairwise'] = attribute_pairwise_distribution(cat_id, graph_data [_networkGraphAttrbuteID][cat_id]['range'] + 1, self.colorizer['category_map']);\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribute_table\", self.colorizer['category_map'], self.colorizer['category_pairwise']);\n    } else {\n        self.colorizer['category']          = null;\n        self.colorizer['category_id']       = null;\n        self.colorizer['category_pairwise'] = null;\n        self.colorizer['category_map']      = null;\n        render_chord_diagram (\"#\" + button_bar_ui + \"_aux_svg_holder\", null, null);\n        render_binned_table  (\"#\" + button_bar_ui + \"_attribite_table\", null, null);\n    }\n    \n    console.log (self.colorizer, graph_data [_networkGraphAttrbuteID]);\n\n    self.update(true);\n    d3.event.preventDefault();\n  }\n  \n  self.filter = function (expressions, skip_update) {\n  \n    var anything_changed = false;\n    \n    self.clusters.forEach (function (c) {\n        c.match_filter = 0;\n    });\n    \n    self.nodes.forEach (function (n) {\n        var did_match = _.some(expressions, function (regexp) {    \n            return regexp.test (n.id)  ;\n        });\n        \n        if (did_match != n.match_filter) {\n            n.match_filter = did_match;\n            anything_changed = true;\n        }\n        \n        if (n.match_filter) {\n            n.parent.match_filter += 1;\n        }\n    });\n    \n    \n    if (anything_changed && !skip_update) {\n        self.update (true);\n    }\n    \n  }\n  \n  self.update = function (soft, friction) {\n  \n    self.needs_an_update = false;\n  \n    if (friction) {\n        network_layout.friction (friction);\n    }\n    if (network_warning_tag) {\n        if (warning_string.length) {\n          d3.select (network_warning_tag).text (warning_string).style (\"display\", \"block\");\n          warning_string = \"\";\n        } else {\n          d3.select (network_warning_tag).style (\"display\", \"none\");  \n        }\n    }\n\n    var rendered_nodes, \n        rendered_clusters,\n        link;\n        \n    if (!soft) {\n\n        var draw_me = prepare_data_to_graph(); \n        \n\n        network_layout.nodes(draw_me.all)\n            .links(draw_me.edges)\n            .start ();\n        \n        update_network_string(draw_me);\n        \n        link = network_svg.selectAll(\".link\")\n            .data(draw_me.edges, function (d) {return d.id;});\n        \n        var link_enter = link.enter().append(\"line\")\n            .classed (\"link\", true)\n            .classed (\"removed\", function (d) {return d.removed;})\n            .classed (\"unsupported\", function (d) { return \"support\" in d && d[\"support\"] > 0.05;})\n            .on (\"mouseover\", edge_pop_on)\n            .on (\"mouseout\", edge_pop_off)\n            .filter (function (d) {return d.directed;})\n            .attr(\"marker-end\", \"url(#arrowhead)\");\n\n        link.exit().remove();\n\n        rendered_nodes  = network_svg.selectAll('.node')\n            .data(draw_me.nodes, function (d) {return d.id;});\n        rendered_nodes.exit().remove();\n        rendered_nodes.enter().append(\"path\");\n        \n        rendered_clusters = network_svg.selectAll (\".cluster-group\").\n          data(draw_me.clusters.map (function (d) {return d;}), function (d) {return d.cluster_id;});\n \n        rendered_clusters.exit().remove();\n        rendered_clusters.enter().append (\"g\").attr (\"class\", \"cluster-group\")\n              .attr (\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; })\n              .on (\"click\", handle_cluster_click)\n              .on (\"mouseover\", cluster_pop_on)\n              .on (\"mouseout\", cluster_pop_off)\n              .call(network_layout.drag().on(\"dragstart\", cluster_pop_off));\n        \n        draw_cluster_table();\n        draw_node_table();\n    \n    } else {\n        rendered_nodes = network_svg.selectAll('.node');\n        rendered_clusters = network_svg.selectAll (\".cluster-group\");\n        link = network_svg.selectAll(\".link\");\n    }\n\n    rendered_nodes.each (function (d) { \n              draw_a_node (this, d);\n             });  \n          \n    rendered_clusters.each (function (d) {\n        draw_a_cluster (this, d);\n    });\n    \n     \n    if (!soft) {\n        currently_displayed_objects = rendered_clusters[0].length + rendered_nodes[0].length;\n\n        network_layout.on(\"tick\", function() {\n        \n          link.attr(\"x1\", function(d) { return d.source.x; })\n              .attr(\"y1\", function(d) { return d.source.y; })\n              .attr(\"x2\", function(d) { return d.target.x; })\n              .attr(\"y2\", function(d) { return d.target.y; });\n\n          rendered_nodes.attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; });\n          rendered_clusters.attr(\"transform\", function(d) { return \"translate(\" + d.x + \",\" + d.y+ \")\"; });\n        });    \n    }\n  }\n\n  function tick() {\n    link.attr(\"x1\", function(d) { return d.source.x; })\n        .attr(\"y1\", function(d) { return d.source.y; })\n        .attr(\"x2\", function(d) { return d.target.x; })\n        .attr(\"y2\", function(d) { return d.target.y; });\n\n    node.attr(\"cx\", function(d) { return d.x; })\n        .attr(\"cy\", function(d) { return d.y; });\n  }\n\n  /*------------ Node Methods ---------------*/\n  function compute_node_degrees(nodes, edges) {\n      for (var n in nodes) {\n          nodes[n].degree = 0;\n      }\n      \n      for (var e in edges) {\n          nodes[edges[e].source].degree++;\n          nodes[edges[e].target].degree++;\n      }\n  }\n\n    \n  function  attribute_node_value_by_id (d, id) {\n     if (_networkGraphAttrbuteID in d ) {\n        if (id) {\n            return d[_networkGraphAttrbuteID][id];\n        }\n     }\n     return null;\n  }\n  \n  function  attribute_name_by_id (id) {\n    if (typeof id == \"number\") {\n        return graph_data [_networkGraphAttrbuteID][id]['label'];\n    }\n    return null;\n  }\n  \n  function node_size (d) {\n    var r = 3+Math.sqrt(d.degree); return (d.match_filter ? 10 : 4)*r*r; \n  }\n\n  function node_color(d) {\n    \n    if (d.match_filter) {\n        return \"white\";\n    }\n  \n    var color = attribute_node_value_by_id (d, self.colorizer['category_id']);\n    if (color) {\n        return self.colorizer['category'](color);\n    }\n    return d.hxb2_linked ? \"black\" : (d.is_lanl ? \"red\" : \"#7fc97f\");\n  }\n\n  function cluster_color(d, type) {\n    if (d[\"binned_attributes\"]) {\n        return self.colorizer['category'](type);\n    }\n    return \"#bdbdbd\";\n  }\n\n  function hxb2_node_color(d) {\n    return \"black\";\n  }\n\n  function node_info_string (n) {\n      var str = \"Degree <em>\" + n.degree + \"</em>\"+\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (n.lcc, _defaultFloatFormat) + \"</em>\";\n                 \n      var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\n      if (attribute) {\n         str += \"<br>\"  + attribute_name_by_id (self.colorizer['category_id']) + \" <em>\" + attribute + \"</em>\"\n      }\n      return str;\n  }\n\n  function edge_info_string (n) {\n     var str = \"Length <em>\" + _defaultFloatFormat(n.length) + \"</em>\";\n     if (\"support\" in n) {\n        str += \"<br>Worst triangle-based support (p): <em>\" + _defaultFloatFormat(n.support) + \"</em>\";\n     }\n                 \n      var attribute = attribute_node_value_by_id (n, self.colorizer['category_id']);\n\n      return str;\n  }\n\n  function node_pop_on (d) {\n      toggle_tooltip (this, true, \"Node \" + d.id, node_info_string (d));\n  }\n\n  function node_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n  function edge_pop_on (e) {\n      toggle_tooltip (this, true, e.source.id + \" - \" + e.target.id, edge_info_string (e));\n  }\n\n  function edge_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n\n  /*------------ Cluster Methods ---------------*/\n\n  function compute_cluster_centroids (clusters) {\n      for (var c in clusters) {\n          var cls = clusters[c];\n          cls.x = 0.;\n          cls.y = 0.;\n          cls.children.forEach (function (x) { cls.x += x.x; cls.y += x.y; });\n          cls.x /= cls.children.length;\n          cls.y /= cls.children.length;\n      }\n  }\n\n  function collapse_cluster(x, keep_in_q) {\n      self.needs_an_update = true;\n      x.collapsed = true;\n      currently_displayed_objects -= self.cluster_sizes[x.cluster_id-1]-1;\n      if (!keep_in_q) {\n          var idx = open_cluster_queue.indexOf(x.cluster_id);\n          if (idx >= 0) {\n           open_cluster_queue.splice (idx,1);\n          }\n      }\n      compute_cluster_centroids ([x]);\n      return x.children.length;\n  }\n\n  function expand_cluster (x, copy_coord) {\n      self.needs_an_update = true;\n      x.collapsed = false;\n      currently_displayed_objects += self.cluster_sizes[x.cluster_id-1]-1;\n      open_cluster_queue.push (x.cluster_id);\n      if (copy_coord) {\n          x.children.forEach (function (n) { n.x = x.x + (Math.random()-0.5)*x.children.length; n.y = x.y + (Math.random()-0.5)*x.children.length; });\n      } else {\n          x.children.forEach (function (n) { n.x = self.width * 0.25 + (Math.random()-0.5)*x.children.length; n.y = 0.25*self.height + (Math.random()-0.5)*x.children.length; })\n      }\n  }\n\n  function render_binned_table (id, the_map, matrix) {\n  \n    var the_table = d3.select (id);\n  \n    the_table.selectAll (\"thead\").remove();\n    the_table.selectAll (\"tbody\").remove();\n    \n    if (matrix) {\n        \n        var fill = self.colorizer['category'];\n        lookup = _.invert (the_map);\n        \n        \n        var headers = the_table.append (\"thead\").append (\"tr\")\n                      .selectAll (\"th\").data ([\"\"].concat (matrix[0].map (function (d,i) {return lookup [i];})));\n                      \n        headers.enter().append (\"th\");\n        headers.html (function (d) { return \"<span>&nbsp;\" + d + \"</span>\";}).each (\n            function (d,i) {\n                if (i) {\n                    d3.select (this).insert (\"i\",\":first-child\")\n                        .classed (\"fa fa-circle\", true)\n                        .style (\"color\", function () {return fill (d);});\n                }\n            }\n        );\n\n        var rows = the_table.append (\"tbody\").selectAll (\"tr\").data (matrix.map (function (d, i) {return [lookup[i]].concat (d);}));\n        rows.enter ().append (\"tr\");\n        rows.selectAll (\"td\").data (function (d) {return d}).enter().append (\"td\").html (function (d, i) {\n            return i == 0 ? (\"<span>&nbsp;\" + d + \"</span>\") : d;\n        }).each (function (d, i) {\n                if (i == 0) {\n                    d3.select (this).insert (\"i\",\":first-child\")\n                        .classed (\"fa fa-circle\", true)\n                        .style (\"color\", function () {return fill (d);});\n                }\n        \n        });\n                      \n        \n\n    }\n  }\n  \n  function render_chord_diagram (id, the_map, matrix) {\n         \n        d3.select (id).selectAll (\"svg\").remove();\n        if (matrix) {\n        \n            lookup = _.invert (the_map);\n            \n  \n            var svg = d3.select (id).append (\"svg\");\n        \n        \n            var chord = d3.layout.chord()\n                .padding(.05)\n                .sortSubgroups(d3.descending)\n                .matrix(matrix);\n\n            var text_offset = 20,\n                width  = 450,\n                height = 450,\n                innerRadius = Math.min(width, height-text_offset) * .41,\n                outerRadius = innerRadius * 1.1;\n\n            var fill = self.colorizer['category'],\n                font_size = 12;\n        \n        \n        \n            var text_label = svg.append (\"g\")\n                                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset)  + \")\")\n                                .append (\"text\")\n                                .attr (\"text-anchor\", \"middle\")\n                                .attr (\"font-size\", font_size)\n                                .text (\"\");\n\n            svg = svg.attr(\"width\", width)\n                .attr(\"height\", height-text_offset)\n                .append(\"g\")\n                .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height-text_offset) / 2 + \")\");\n            \n    \n            svg.append(\"g\").selectAll(\"path\")\n                .data(chord.groups)\n              .enter().append(\"path\")\n                .style(\"fill\", function(d)   { return fill(lookup[d.index]); })\n                .style(\"stroke\", function(d) { return fill(lookup[d.index]); })\n                .attr(\"d\", d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius))\n                .on(\"mouseover\", fade(0.1,true))\n                .on(\"mouseout\", fade(1,false));\n\n        \n\n            svg.append(\"g\")\n                .attr(\"class\", \"chord\")\n              .selectAll(\"path\")\n                .data(chord.chords)\n              .enter().append(\"path\")\n                .attr(\"d\", d3.svg.chord().radius(innerRadius))\n                .style(\"fill\", function(d) { return fill(d.target.index); })\n                .style(\"opacity\", 1);\n\n            // Returns an event handler for fading a given chord group.\n            function fade(opacity,t) {\n              return function(g, i) {\n                text_label.text (t ? lookup[i] : \"\");\n                svg.selectAll(\".chord path\")\n                    .filter(function(d) { return d.source.index != i && d.target.index != i; })\n                  .transition()\n                    .style(\"opacity\", opacity);\n              };\n            }\n        }\n  }\n\n  function attribute_pairwise_distribution (id, dim, the_map, only_expanded) {\n        var scan_from = only_expanded ? draw_me.edges : self.edges;\n        var the_matrix = [];\n        for (i = 0 ; i < dim; i+=1) {\n            the_matrix.push([]);\n            for (j = 0; j < dim; j += 1){\n                the_matrix[i].push (0);\n            }\n        }  \n        scan_from.forEach (function (edge) { the_matrix[the_map[attribute_node_value_by_id(self.nodes[edge.source], id)]][the_map[attribute_node_value_by_id(self.nodes[edge.target], id)]] += 1;});\n        // check if there are null values\n        \n        var haz_null = the_matrix.some (function (d, i) { if (i == dim - 1) {return d.some (function (d2) {return d2 > 0;});} return d[dim-1] > 0;});\n        if (!haz_null) {\n            the_matrix.pop();\n            for (i = 0 ; i < dim - 1; i+=1) {\n                the_matrix[i].pop();\n            }\n        }\n        \n        return the_matrix;\n  }\n    \n  function attribute_cluster_distribution (the_cluster, attribute_id) {\n        if (attribute_id >= 0 && the_cluster) {\n            return the_cluster.children.map (function (d) {return (_networkGraphAttrbuteID in d) ? d[_networkGraphAttrbuteID][attribute_id] : null;});\n        }\n        return null;\n  }\n\n  function cluster_info_string (id) {\n      var the_cluster = self.clusters[id-1],\n          attr_info = the_cluster[\"binned_attributes\"];\n          \n          \n\n      var str = \"<strong>\" + self.cluster_sizes[id-1] + \"</strong> nodes.\" + \n             \"<br>Mean degree <em>\" + _defaultFloatFormat(the_cluster.degrees['mean']) + \"</em>\" +\n             \"<br>Max degree <em>\" + the_cluster.degrees['max'] + \"</em>\" +\n             \"<br>Clustering coefficient <em> \" + datamonkey.hivtrace.format_value (the_cluster.cc, _defaultFloatFormat) + \"</em>\";\n      \n      if (attr_info) {\n            attr_info.forEach (function (d) { str += \"<br>\" + d[0] + \" <em>\" + d[1] + \"</em>\"});\n      }\n             \n      return str;\n  }\n\n  function cluster_pop_on (d) {\n      toggle_tooltip (this, true, \"Cluster \" + d.cluster_id, cluster_info_string (d.cluster_id));\n  }\n\n  function cluster_pop_off (d) {\n      toggle_tooltip (this, false);\n  }\n\n  function expand_cluster_handler (d, do_update, move_out) {\n    if (d.collapsed) {  \n        var new_nodes = self.cluster_sizes[d.cluster_id-1] - 1;\n        \n        if (new_nodes > max_points_to_render) {\n            warning_string = \"This cluster is too large to be displayed\";\n        }\n        else {\n            var leftover = new_nodes + currently_displayed_objects - max_points_to_render;\n            if (leftover > 0) {\n              for (k = 0; k < open_cluster_queue.length && leftover > 0; k++) {\n                  var cluster = self.clusters[cluster_mapping[open_cluster_queue[k]]];\n                  leftover -= cluster.children.length - 1;\n                  collapse_cluster(cluster,true);\n              }\n              if (k || open_cluster_queue.length) {\n                  open_cluster_queue.splice (0, k);\n              }\n            }\n    \n            if (leftover <= 0) {\n                expand_cluster (d, !move_out);\n            }\n        }\n            \n        if (do_update) {\n            self.update(false, 0.6);\n        }\n    }\n    return \"\";\n  }\n\n  function collapse_cluster_handler (d, do_update) {\n    collapse_cluster(self.clusters[cluster_mapping[d.cluster]]);\n    if (do_update) {       \n        self.update(false, 0.4);\n    }\n    \n  }\n\n  function center_cluster_handler (d) {\n    d.x = self.width/2;\n    d.y = self.height/2;\n    self.update(false, 0.4);\n  }\n\n  function cluster_box_size (c) {\n      return 5*Math.sqrt (c.children.length);\n  }\n\n  self.expand_some_clusters = function(subset)  {\n    subset = subset || self.clusters;\n    subset.forEach (function (x) { expand_cluster_handler (x, false); });\n    self.update (); \n  }\n  \n  self.select_some_clusters = function (condition) {\n    return self.clusters.filter (function (c, i) {\n        return _.some(c.children, (function (n) {return condition (n);}));\n    });\n  }\n\n  self.collapse_some_clusters = function(subset) {\n    subset = subset || self.clusters;\n    subset.forEach (function (x) { if (!x.collapsed) collapse_cluster (x); });\n    self.update();\n  }\n\n  self.toggle_hxb2 = function()  {\n    self.hide_hxb2 = !self.hide_hxb2;\n    self.update();\n  }\n\n  $('#reset_layout').click(function(e) {\n    default_layout(clusters, nodes);\n    self.update ();\n    e.preventDefault();// prevent the default anchor functionality\n    });\n\n  function stratify (array) {\n    if (array) {\n        var dict = {},\n            stratified = [];\n        \n        array.forEach (function (d) { if (d in dict) {dict[d] += 1;} else {dict[d] = 1;}});\n        for (var uv in dict) {\n            stratified.push ([uv, dict[uv]]);\n        }\n        return stratified.sort (function (a,b) {\n              return a[0] - b[0];\n            });\n     }\n     return array;\n   }\n\n  /*------------ Event Functions ---------------*/\n  function toggle_tooltip(element, turn_on, title, tag) {\n    //if (d3.event.defaultPrevented) return;\n    if (turn_on && !element.tooltip) {\n    \n      // check to see if there are any other tooltips shown\n     ($(\"[role='tooltip']\")).each (function (d) {\n        $(this).remove();\n     });\n    \n      var this_box = $(element);\n      var this_data = d3.select(element).datum();\n      element.tooltip = this_box.tooltip({\n                 title: title + \"<br>\" + tag,\n                 html: true,\n                 container: 'body',\n               });\n               \n      //this_data.fixed = true;\n      \n      _.delay (_.bind(element.tooltip.tooltip, element.tooltip), 500, 'show');\n    } else {\n      if (turn_on == false && element.tooltip) {\n        element.tooltip.tooltip('destroy');\n        element.tooltip = undefined;\n      }\n    }\n  }\n  initial_json_load();       \n  return self;\n}\n\n\n\nvar hivtrace_cluster_graph_summary = function (graph, tag) {\n \n    var summary_table = d3.select (tag).append (\"tbody\");\n    \n    var table_data = [];\n    \n    if (!summary_table.empty()) {\n        _.each (graph[\"Network Summary\"], function (value, key) {\n            table_data.push ([key, value]);\n        });\n    }\n    \n    var degrees = [];\n    _.each (graph [\"Degrees\"][\"Distribution\"], function (value, index) { for (k = 0; k < value; k++) {degrees.push (index+1);}});    \n    degrees = datamonkey.helpers.describe_vector (degrees);\n    table_data.push (['Degrees', '']);\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n\n    degrees = datamonkey.helpers.describe_vector (graph [\"Cluster sizes\"]);\n    table_data.push (['Cluster sizes', '']);\n    table_data.push (['&nbsp;&nbsp;<i>Mean</i>',  _defaultFloatFormat(degrees['mean'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Median</i>',  _defaultFloatFormat(degrees['median'])]);\n    table_data.push (['&nbsp;&nbsp;<i>Range</i>', degrees['min'] + \" - \" + degrees['max']]);\n    table_data.push (['&nbsp;&nbsp;<i>IQR</i>', degrees['Q1'] + \" - \" + degrees['Q3']]);\n    \n    \n    summary_table.selectAll (\"tr\").data (table_data).enter().append (\"tr\").selectAll (\"td\").data (function (d) {return d;}).enter().append (\"td\").html (function (d) {return d});\n}\n\ndatamonkey.hivtrace.cluster_network_graph = hivtrace_cluster_network_graph;\ndatamonkey.hivtrace.graph_summary = hivtrace_cluster_graph_summary;\n"],"sourceRoot":"/source/"}